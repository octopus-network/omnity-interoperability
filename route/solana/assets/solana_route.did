type Chain = record {
  fee_token : opt text;
  canister_id : text;
  chain_id : text;
  counterparties : opt vec text;
  chain_state : ChainState;
  chain_type : ChainType;
  contract_address : opt text;
};
type ChainState = variant { Active; Deactive };
type ChainType = variant { SettlementChain; ExecutionChain };
type Event = variant {
  finalized_gen_ticket : record {
    request : GenerateTicketReq;
    ticket_id : text;
  };
  updated_fee : record { fee : Factor };
  finalized_mint_token : record { signature : text; ticket_id : text };
  added_token : Token;
  init : InitArgs;
  upgrade : UpgradeArgs;
  added_chain : Chain;
  toggle_chain_state : ToggleState;
};
type Factor = variant {
  UpdateFeeTokenFactor : FeeTokenFactor;
  UpdateTargetChainFactor : TargetChainFactor;
};
type FeeTokenFactor = record { fee_token : text; fee_token_factor : nat };
type GenerateTicketError = variant {
  InsufficientRedeemFee : record { provided : nat64; required : nat64 };
  SendTicketErr : text;
  TemporarilyUnavailable : text;
  InsufficientAllowance : record { allowance : nat64 };
  TransferFailure : text;
  UnsupportedAction : text;
  RedeemFeeNotSet;
  UnsupportedChainId : text;
  UnsupportedToken : text;
  InsufficientFunds : record { balance : nat64 };
};
type GenerateTicketOk = record { ticket_id : text };
type GenerateTicketReq = record {
  signature : text;
  action : TxAction;
  token_id : text;
  memo : opt text;
  sender : text;
  target_chain_id : text;
  amount : nat64;
  receiver : text;
};
type GetEventsArg = record { start : nat64; length : nat64 };
type InitArgs = record {
  admin : principal;
  hub_principal : principal;
  sol_canister : principal;
  chain_id : text;
  schnorr_canister : principal;
  schnorr_key_name : opt text;
  chain_state : ChainState;
};
type MintTokenStatus = variant {
  Finalized : record { signature : text };
  Unknown;
};
type Permission = variant { Update; Query };
type Result = variant { Ok; Err : text };
type Result_1 = variant { Ok : GenerateTicketOk; Err : GenerateTicketError };
type Result_2 = variant { Ok; Err : TransactionError };
type Result_3 = variant { Ok : text; Err : text };
type Result_4 = variant { Ok; Err : GenerateTicketError };
type RouteArg = variant { Upgrade : opt UpgradeArgs; Init : InitArgs };
type TargetChainFactor = record {
  target_chain_id : text;
  target_chain_factor : nat;
};
type Ticket = record {
  token : text;
  action : TxAction;
  dst_chain : text;
  memo : opt blob;
  ticket_id : text;
  sender : opt text;
  ticket_time : nat64;
  ticket_type : TicketType;
  src_chain : text;
  amount : text;
  receiver : text;
};
type TicketType = variant { Resubmit; Normal };
type ToggleAction = variant { Deactivate; Activate };
type ToggleState = record { action : ToggleAction; chain_id : text };
type Token = record {
  decimals : nat8;
  token_id : text;
  metadata : vec record { text; text };
  icon : opt text;
  name : text;
  symbol : text;
};
type TokenCreateInfo = record {
  uri : text;
  decimals : nat8;
  name : text;
  symbol : text;
};
type TokenResp = record {
  decimals : nat8;
  token_id : text;
  icon : opt text;
  rune_id : opt text;
  symbol : text;
};
type TransactionConfirmationStatus = variant {
  Finalized;
  Confirmed;
  Processed;
};
type TransactionError = variant {
  InvalidAccountForFee;
  AddressLookupTableNotFound;
  MissingSignatureForFee;
  WouldExceedAccountDataBlockLimit;
  AccountInUse;
  DuplicateInstruction : nat8;
  AccountNotFound;
  TooManyAccountLocks;
  InvalidAccountIndex;
  AlreadyProcessed;
  WouldExceedAccountDataTotalLimit;
  InvalidAddressLookupTableIndex;
  SanitizeFailure;
  ResanitizationNeeded;
  InvalidRentPayingAccount;
  MaxLoadedAccountsDataSizeExceeded;
  InvalidAddressLookupTableData;
  InvalidWritableAccount;
  WouldExceedMaxAccountCostLimit;
  InvalidLoadedAccountsDataSizeLimit;
  InvalidProgramForExecution;
  InstructionError : record { nat8; text };
  InsufficientFundsForRent : record { account_index : nat8 };
  UnsupportedVersion;
  ClusterMaintenance;
  WouldExceedMaxVoteCostLimit;
  SignatureFailure;
  ProgramAccountNotFound;
  AccountLoadedTwice;
  ProgramExecutionTemporarilyRestricted : record { account_index : nat8 };
  AccountBorrowOutstanding;
  WouldExceedMaxBlockCostLimit;
  InvalidAddressLookupTableOwner;
  InsufficientFundsForFee;
  CallChainTooDeep;
  UnbalancedTransaction;
  BlockhashNotFound;
};
type TransactionStatus = record {
  err : opt TransactionError;
  confirmations : opt nat64;
  status : Result_2;
  slot : nat64;
  confirmation_status : opt TransactionConfirmationStatus;
};
type TxAction = variant { Burn; Redeem; Mint; Transfer };
type UpgradeArgs = record {
  hub_principal : opt principal;
  sol_canister : opt principal;
  chain_id : opt text;
  schnorr_canister : opt principal;
  schnorr_key_name : opt text;
  chain_state : opt ChainState;
};
service : (RouteArg) -> {
  cannel_schedule : () -> (Result);
  create_mint : (TokenCreateInfo) -> (text);
  generate_ticket : (GenerateTicketReq) -> (Result_1);
  get_chain_list : () -> (vec Chain) query;
  get_events : (GetEventsArg) -> (vec Event) query;
  get_latest_blockhash : () -> (text);
  get_or_create_aossicated_account : (text, text) -> (text);
  get_redeem_fee : (text) -> (opt nat) query;
  get_signature_status : (vec text) -> (vec TransactionStatus);
  get_tickets_from_queue : () -> (vec record { nat64; Ticket }) query;
  get_token_list : () -> (vec TokenResp) query;
  get_transaction : (text) -> (text);
  handle_mint_token : () -> ();
  mint_to : (text, nat64, text) -> (text);
  mint_token_status : (text) -> (MintTokenStatus) query;
  payer : () -> (Result_3);
  query_aossicated_account : () -> (
      vec record { record { text; text }; text },
    ) query;
  query_token_mint : () -> (vec record { text; text }) query;
  resend_tickets : () -> (Result_4);
  set_permissions : (principal, Permission) -> ();
  start_schedule : () -> (Result);
  update_schnorr_info : (principal, text) -> (Result);
}
