#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use ic_cdk::api::call::RejectionCode;
use thiserror::Error;
pub mod audit {
    use crate::state::CdkRouteState;
    use crate::types::{Chain, Factor, ToggleState, Token};
    pub fn add_chain(state: &mut CdkRouteState, chain: Chain) {
        state.counterparties.insert(chain.chain_id.clone(), chain);
    }
    pub fn add_token(state: &mut CdkRouteState, token: Token) {
        let token_id = token.token_id.clone();
        state.tokens.insert(token_id.clone(), token);
    }
    pub fn toggle_chain_state(state: &mut CdkRouteState, toggle: ToggleState) {
        if toggle.chain_id == state.omnity_chain_id {
            state.chain_state = toggle.action.into();
        } else if let Some(chain) = state.counterparties.get_mut(&toggle.chain_id) {
            chain.chain_state = toggle.action.into();
        }
    }
    pub fn finalize_mint_token_req(
        state: &mut CdkRouteState,
        ticket_id: String,
        finalized_block_index: u64,
    ) {
        state.finalized_mint_token_requests.insert(ticket_id, finalized_block_index);
    }
    pub fn update_fee(state: &mut CdkRouteState, fee: Factor) {}
}
pub mod call_error {
    use ic_cdk::api::call::RejectionCode;
    use std::fmt;
    /// Represents an error from a management canister call, such as
    /// `sign_with_ecdsa` or `bitcoin_send_transaction`.
    pub struct CallError {
        pub method: String,
        pub reason: Reason,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CallError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "CallError",
                "method",
                &self.method,
                "reason",
                &&self.reason,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CallError {
        #[inline]
        fn clone(&self) -> CallError {
            CallError {
                method: ::core::clone::Clone::clone(&self.method),
                reason: ::core::clone::Clone::clone(&self.reason),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CallError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CallError {
        #[inline]
        fn eq(&self, other: &CallError) -> bool {
            self.method == other.method && self.reason == other.reason
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CallError {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CallError {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Reason>;
        }
    }
    impl fmt::Display for CallError {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt.write_fmt(
                format_args!(
                    "management call \'{0}\' failed: {1}",
                    self.method,
                    self.reason,
                ),
            )
        }
    }
    /// The reason for the management call failure.
    pub enum Reason {
        /// Failed to send a signature request because the local output queue is
        /// full.
        QueueIsFull,
        /// The canister does not have enough cycles to submit the request.
        OutOfCycles,
        /// The call failed with an error.
        CanisterError(String),
        /// The management canister rejected the signature request (not enough
        /// cycles, the ECDSA subnet is overloaded, etc.).
        Rejected(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Reason {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Reason::QueueIsFull => {
                    ::core::fmt::Formatter::write_str(f, "QueueIsFull")
                }
                Reason::OutOfCycles => {
                    ::core::fmt::Formatter::write_str(f, "OutOfCycles")
                }
                Reason::CanisterError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CanisterError",
                        &__self_0,
                    )
                }
                Reason::Rejected(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rejected",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Reason {
        #[inline]
        fn clone(&self) -> Reason {
            match self {
                Reason::QueueIsFull => Reason::QueueIsFull,
                Reason::OutOfCycles => Reason::OutOfCycles,
                Reason::CanisterError(__self_0) => {
                    Reason::CanisterError(::core::clone::Clone::clone(__self_0))
                }
                Reason::Rejected(__self_0) => {
                    Reason::Rejected(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Reason {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Reason {
        #[inline]
        fn eq(&self, other: &Reason) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        Reason::CanisterError(__self_0),
                        Reason::CanisterError(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Reason::Rejected(__self_0), Reason::Rejected(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Reason {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Reason {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    impl fmt::Display for Reason {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::QueueIsFull => {
                    fmt.write_fmt(format_args!("the canister queue is full"))
                }
                Self::OutOfCycles => {
                    fmt.write_fmt(format_args!("the canister is out of cycles"))
                }
                Self::CanisterError(msg) => {
                    fmt.write_fmt(format_args!("canister error: {0}", msg))
                }
                Self::Rejected(msg) => {
                    fmt.write_fmt(
                        format_args!(
                            "the management canister rejected the call: {0}",
                            msg,
                        ),
                    )
                }
            }
        }
    }
    impl Reason {
        pub fn from_reject(reject_code: RejectionCode, reject_message: String) -> Self {
            match reject_code {
                RejectionCode::CanisterReject => Self::Rejected(reject_message),
                _ => Self::CanisterError(reject_message),
            }
        }
    }
}
pub mod cdk_scan {
    use crate::contracts::{
        DirectiveExecutedFilter, TokenBurnedFilter, TokenMintedFilter,
        TokenTransportRequestedFilter,
    };
    use crate::state::{mutate_state, read_state};
    use crate::types::Ticket;
    use crate::*;
    use cketh_common::{
        eth_rpc::LogEntry, eth_rpc_client::RpcConfig, numeric::BlockNumber,
    };
    use ethers_contract::EthEvent;
    use ethers_core::abi::{AbiEncode, Log, RawLog};
    use ethers_core::utils::keccak256;
    use evm_rpc::{
        candid_types::{self, BlockTag},
        MultiRpcResult, RpcServices,
    };
    use itertools::Itertools;
    use log::{error, info};
    const MAX_SCAN_BLOCKS: u64 = 20;
    pub fn scan_cdk_task() {
        ic_cdk::spawn(async {
            let _guard = match crate::guard::TimerLogicGuard::new() {
                Some(guard) => guard,
                None => return,
            };
            let _ = handle_port_events().await;
        });
    }
    pub async fn handle_port_events() -> anyhow::Result<()> {
        use anyhow::anyhow;
        let (from, to) = determine_from_to().await?;
        let contract_addr = read_state(|s| s.omnity_port_contract.0.encode_hex());
        let logs = fetch_logs(from, to, contract_addr).await?;
        for l in logs {
            if l.removed {
                return Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("log is removed"),
                        );
                        error
                    }),
                );
            }
            let block = l
                .block_number
                .ok_or(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("block is pending"),
                        );
                        error
                    }),
                )?;
            let log_index = l
                .log_index
                .ok_or(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("log is pending"),
                        );
                        error
                    }),
                )?;
            let log_key = {
                let res = ::alloc::fmt::format(
                    format_args!("{0}-{1}", block, log_index),
                );
                res
            };
            if read_state(|s| s.handled_cdk_event.contains(&log_key)) {
                continue;
            }
            let topic1 = l
                .topics
                .first()
                .ok_or(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("topic is none"),
                        );
                        error
                    }),
                )?
                .0
                .clone();
            let raw_log: RawLog = RawLog {
                topics: l.topics.iter().map(|topic| topic.0.into()).collect_vec(),
                data: l.data.0.clone(),
            };
            if topic1 == keccak256(TokenBurnedFilter::abi_signature().as_bytes()) {
                let token_burned = TokenBurnedFilter::decode_log(&raw_log)
                    .map_err(|e| super::Error::ParseEventError(e.to_string()))?;
                handle_token_burn(&l, token_burned).await?;
            } else if topic1 == keccak256(TokenMintedFilter::abi_signature().as_bytes())
            {
                let token_mint = TokenMintedFilter::decode_log(&raw_log)
                    .map_err(|e| super::Error::ParseEventError(e.to_string()))?;
                handle_token_mint(token_mint);
            } else if topic1
                == keccak256(TokenTransportRequestedFilter::abi_signature().as_bytes())
            {
                let token_transport = TokenTransportRequestedFilter::decode_log(&raw_log)
                    .map_err(|e| super::Error::ParseEventError(e.to_string()))?;
                handle_token_transport(&l, token_transport).await?;
            }
            mutate_state(|s| s.handled_cdk_event.insert(log_key));
        }
        mutate_state(|s| s.scan_start_height = to);
        Ok(())
    }
    pub async fn handle_token_burn(
        log_entry: &LogEntry,
        event: TokenBurnedFilter,
    ) -> anyhow::Result<()> {
        let ticket = Ticket::from_burn_event(&log_entry, event);
        ic_cdk::call(crate::state::hub_addr(), "send_ticket", (ticket,))
            .await
            .map_err(|(_, s)| Error::HubError(s))?;
        Ok(())
    }
    pub fn handle_token_mint(event: TokenMintedFilter) {
        let tid = event.ticket_id.to_string();
        mutate_state(|s| s.pending_tickets_map.remove(&tid));
    }
    pub async fn handle_token_transport(
        log_entry: &LogEntry,
        event: TokenTransportRequestedFilter,
    ) -> anyhow::Result<()> {
        let ticket = Ticket::from_transport_event(&log_entry, event);
        ic_cdk::call(crate::state::hub_addr(), "send_ticket", (ticket,))
            .await
            .map_err(|(_, s)| Error::HubError(s))?;
        Ok(())
    }
    async fn determine_from_to() -> anyhow::Result<(u64, u64)> {
        let from_height = read_state(|s| s.scan_start_height);
        let to_height = get_cdk_finalized_height()
            .await
            .map_err(|e| {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "query cdk block height error: {0:?}",
                                e.to_string(),
                            ),
                            lvl,
                            &(
                                "cdk_route::cdk_scan",
                                "cdk_route::cdk_scan",
                                "src/cdk_scan.rs",
                            ),
                            100u32,
                            (),
                        );
                    }
                };
                e
            })?;
        Ok((from_height, to_height.min(from_height + MAX_SCAN_BLOCKS)))
    }
    pub async fn get_cdk_finalized_height() -> anyhow::Result<u64> {
        let json_rpc_payload = r#"{"method":"eth_blockNumber","params":[],"id":1,"jsonrpc":"2.0"}"#;
        let (result,): (u64,) = ic_cdk::api::call::call(
                crate::state::rpc_addr(),
                "request",
                (
                    RpcServices::Custom {
                        chain_id: crate::state::target_chain_id(),
                        services: crate::state::rpc_providers(),
                    },
                    json_rpc_payload,
                    100000,
                ),
            )
            .await
            .map_err(|err| Error::IcCallError(err.0, err.1))?;
        {
            let lvl = ::log::Level::Info;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!("received get cdk finalized height: {0}", result),
                    lvl,
                    &("cdk_route::cdk_scan", "cdk_route::cdk_scan", "src/cdk_scan.rs"),
                    122u32,
                    (),
                );
            }
        };
        Ok(result - 12)
    }
    pub async fn fetch_logs(
        from_height: u64,
        to_height: u64,
        address: String,
    ) -> std::result::Result<Vec<LogEntry>, Error> {
        let (rpc_result,): (MultiRpcResult<Vec<LogEntry>>,) = ic_cdk::api::call::call(
                crate::state::rpc_addr(),
                "eth_getLogs",
                (
                    RpcServices::Custom {
                        chain_id: crate::state::target_chain_id(),
                        services: crate::state::rpc_providers(),
                    },
                    None::<RpcConfig>,
                    candid_types::GetLogsArgs {
                        from_block: Some(
                            BlockTag::Number(BlockNumber::from(from_height)),
                        ),
                        to_block: Some(BlockTag::Number(BlockNumber::from(to_height))),
                        addresses: <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([address]),
                        ),
                        topics: Some(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            keccak256(
                                                    TokenBurnedFilter::abi_signature().to_owned().as_bytes(),
                                                )
                                                .encode_hex(),
                                        ]),
                                    ),
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            keccak256(
                                                    TokenMintedFilter::abi_signature().to_owned().as_bytes(),
                                                )
                                                .encode_hex(),
                                        ]),
                                    ),
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            keccak256(
                                                    TokenTransportRequestedFilter::abi_signature()
                                                        .to_owned()
                                                        .as_bytes(),
                                                )
                                                .encode_hex(),
                                        ]),
                                    ),
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            keccak256(
                                                    DirectiveExecutedFilter::abi_signature()
                                                        .to_owned()
                                                        .as_bytes(),
                                                )
                                                .encode_hex(),
                                        ]),
                                    ),
                                ]),
                            ),
                        ),
                    },
                ),
            )
            .await
            .map_err(|err| Error::IcCallError(err.0, err.1))?;
        match rpc_result {
            MultiRpcResult::Consistent(result) => {
                result
                    .map_err(|e| {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!("fetch logs rpc error: {0:?}", e.clone()),
                                    lvl,
                                    &(
                                        "cdk_route::cdk_scan",
                                        "cdk_route::cdk_scan",
                                        "src/cdk_scan.rs",
                                    ),
                                    175u32,
                                    (),
                                );
                            }
                        };
                        Error::EvmRpcError({
                            let res = ::alloc::fmt::format(format_args!("{0:?}", e));
                            res
                        })
                    })
            }
            MultiRpcResult::Inconsistent(_) => {
                return Result::Err(
                    super::Error::EvmRpcError("Inconsistent result".to_string()),
                );
            }
        }
    }
}
pub mod contracts {
    use std::str::FromStr;
    use ethers_contract::{abigen, EthEvent};
    use ethers_core::abi::{ethereum_types, AbiEncode};
    use ethers_core::types::{Bytes, Eip1559TransactionRequest, NameOrAddress, U256};
    use ethers_core::utils::keccak256;
    use serde_derive::{Deserialize, Serialize};
    use crate::eth_common::EvmAddress;
    use crate::state::read_state;
    use crate::types::{Directive, Ticket, ToggleAction};
    pub type PortContractCommandIndex = u8;
    pub use omnity_port_contract::*;
    /// This module was auto-generated with ethers-rs Abigen.
    /// More information at: <https://github.com/gakonst/ethers-rs>
    #[allow(
        clippy::enum_variant_names,
        clippy::too_many_arguments,
        clippy::upper_case_acronyms,
        clippy::type_complexity,
        dead_code,
        non_camel_case_types,
    )]
    pub mod omnity_port_contract {
        #[allow(deprecated)]
        fn __abi() -> ::ethers_core::abi::Abi {
            ::ethers_core::abi::ethabi::Contract {
                constructor: ::core::option::Option::None,
                functions: ::core::convert::From::from([
                    (
                        ::std::borrow::ToOwned::to_owned("privilegedExecuteDirective"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Function {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "privilegedExecuteDirective",
                                    ),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("directiveBytes"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Bytes,
                                                internal_type: ::core::option::Option::None,
                                            },
                                        ]),
                                    ),
                                    outputs: ::alloc::vec::Vec::new(),
                                    constant: ::core::option::Option::None,
                                    state_mutability: ::ethers_core::abi::ethabi::StateMutability::NonPayable,
                                },
                            ]),
                        ),
                    ),
                    (
                        ::std::borrow::ToOwned::to_owned("privilegedMintToken"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Function {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "privilegedMintToken",
                                    ),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                internal_type: ::core::option::Option::None,
                                            },
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("receiver"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Address,
                                                internal_type: ::core::option::Option::None,
                                            },
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("amount"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                internal_type: ::core::option::Option::None,
                                            },
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("ticketId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                internal_type: ::core::option::Option::None,
                                            },
                                            ::ethers_core::abi::ethabi::Param {
                                                name: ::std::borrow::ToOwned::to_owned("memo"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                internal_type: ::core::option::Option::None,
                                            },
                                        ]),
                                    ),
                                    outputs: ::alloc::vec::Vec::new(),
                                    constant: ::core::option::Option::None,
                                    state_mutability: ::ethers_core::abi::ethabi::StateMutability::NonPayable,
                                },
                            ]),
                        ),
                    ),
                ]),
                events: ::core::convert::From::from([
                    (
                        ::std::borrow::ToOwned::to_owned("DirectiveExecuted"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Event {
                                    name: ::std::borrow::ToOwned::to_owned("DirectiveExecuted"),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("seq"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                indexed: false,
                                            },
                                        ]),
                                    ),
                                    anonymous: false,
                                },
                            ]),
                        ),
                    ),
                    (
                        ::std::borrow::ToOwned::to_owned("TokenBurned"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Event {
                                    name: ::std::borrow::ToOwned::to_owned("TokenBurned"),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("receiver"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("amount"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("channelId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                        ]),
                                    ),
                                    anonymous: false,
                                },
                            ]),
                        ),
                    ),
                    (
                        ::std::borrow::ToOwned::to_owned("TokenMinted"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Event {
                                    name: ::std::borrow::ToOwned::to_owned("TokenMinted"),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("receiver"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Address,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("amount"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("ticketId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("memo"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                        ]),
                                    ),
                                    anonymous: false,
                                },
                            ]),
                        ),
                    ),
                    (
                        ::std::borrow::ToOwned::to_owned("TokenTransportRequested"),
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::ethers_core::abi::ethabi::Event {
                                    name: ::std::borrow::ToOwned::to_owned(
                                        "TokenTransportRequested",
                                    ),
                                    inputs: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("dstChainId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("tokenId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("receiver"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("amount"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::Uint(256usize),
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("channelId"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                            ::ethers_core::abi::ethabi::EventParam {
                                                name: ::std::borrow::ToOwned::to_owned("memo"),
                                                kind: ::ethers_core::abi::ethabi::ParamType::String,
                                                indexed: false,
                                            },
                                        ]),
                                    ),
                                    anonymous: false,
                                },
                            ]),
                        ),
                    ),
                ]),
                errors: ::std::collections::BTreeMap::new(),
                receive: false,
                fallback: false,
            }
        }
        ///The parsed human-readable ABI of the contract.
        pub static OMNITYPORTCONTRACT_ABI: ::ethers_contract::Lazy<
            ::ethers_core::abi::Abi,
        > = ::ethers_contract::Lazy::new(__abi);
        pub struct OmnityPortContract<M>(::ethers_contract::Contract<M>);
        impl<M> ::core::clone::Clone for OmnityPortContract<M> {
            fn clone(&self) -> Self {
                Self(::core::clone::Clone::clone(&self.0))
            }
        }
        impl<M> ::core::ops::Deref for OmnityPortContract<M> {
            type Target = ::ethers_contract::Contract<M>;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl<M> ::core::ops::DerefMut for OmnityPortContract<M> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<M> ::core::fmt::Debug for OmnityPortContract<M> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_tuple("OmnityPortContract").field(&self.address()).finish()
            }
        }
        impl<M: ::ethers_providers::Middleware> OmnityPortContract<M> {
            /// Creates a new contract instance with the specified `ethers` client at
            /// `address`. The contract derefs to a `ethers::Contract` object.
            pub fn new<T: Into<::ethers_core::types::Address>>(
                address: T,
                client: ::std::sync::Arc<M>,
            ) -> Self {
                Self(
                    ::ethers_contract::Contract::new(
                        address.into(),
                        OMNITYPORTCONTRACT_ABI.clone(),
                        client,
                    ),
                )
            }
            ///Calls the contract's `privilegedExecuteDirective` (0x77b91045) function
            pub fn privileged_execute_directive(
                &self,
                directive_bytes: ::ethers_core::types::Bytes,
            ) -> ::ethers_contract::builders::ContractCall<M, ()> {
                self.0
                    .method_hash([119, 185, 16, 69], directive_bytes)
                    .expect("method not found (this should never happen)")
            }
            ///Calls the contract's `privilegedMintToken` (0x582fd22d) function
            pub fn privileged_mint_token(
                &self,
                token_id: ::std::string::String,
                receiver: ::ethers_core::types::Address,
                amount: ::ethers_core::types::U256,
                ticket_id: ::ethers_core::types::U256,
                memo: ::std::string::String,
            ) -> ::ethers_contract::builders::ContractCall<M, ()> {
                self.0
                    .method_hash(
                        [88, 47, 210, 45],
                        (token_id, receiver, amount, ticket_id, memo),
                    )
                    .expect("method not found (this should never happen)")
            }
            ///Gets the contract's `DirectiveExecuted` event
            pub fn directive_executed_filter(
                &self,
            ) -> ::ethers_contract::builders::Event<
                ::std::sync::Arc<M>,
                M,
                DirectiveExecutedFilter,
            > {
                self.0.event()
            }
            ///Gets the contract's `TokenBurned` event
            pub fn token_burned_filter(
                &self,
            ) -> ::ethers_contract::builders::Event<
                ::std::sync::Arc<M>,
                M,
                TokenBurnedFilter,
            > {
                self.0.event()
            }
            ///Gets the contract's `TokenMinted` event
            pub fn token_minted_filter(
                &self,
            ) -> ::ethers_contract::builders::Event<
                ::std::sync::Arc<M>,
                M,
                TokenMintedFilter,
            > {
                self.0.event()
            }
            ///Gets the contract's `TokenTransportRequested` event
            pub fn token_transport_requested_filter(
                &self,
            ) -> ::ethers_contract::builders::Event<
                ::std::sync::Arc<M>,
                M,
                TokenTransportRequestedFilter,
            > {
                self.0.event()
            }
            /// Returns an `Event` builder for all the events of this contract.
            pub fn events(
                &self,
            ) -> ::ethers_contract::builders::Event<
                ::std::sync::Arc<M>,
                M,
                OmnityPortContractEvents,
            > {
                self.0.event_with_filter(::core::default::Default::default())
            }
        }
        impl<M: ::ethers_providers::Middleware> From<::ethers_contract::Contract<M>>
        for OmnityPortContract<M> {
            fn from(contract: ::ethers_contract::Contract<M>) -> Self {
                Self::new(contract.address(), contract.client())
            }
        }
        #[ethevent(name = "DirectiveExecuted", abi = "DirectiveExecuted(uint256)")]
        pub struct DirectiveExecutedFilter {
            pub seq: ::ethers_core::types::U256,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DirectiveExecutedFilter {
            #[inline]
            fn clone(&self) -> DirectiveExecutedFilter {
                DirectiveExecutedFilter {
                    seq: ::core::clone::Clone::clone(&self.seq),
                }
            }
        }
        impl ::ethers_core::abi::AbiType for DirectiveExecutedFilter {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for DirectiveExecutedFilter {}
        impl ::ethers_core::abi::Tokenizable for DirectiveExecutedFilter
        where
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 1usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 1 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        seq: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([self.seq.into_token()]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for DirectiveExecutedFilter
        where
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_contract::EthEvent for DirectiveExecutedFilter {
            fn name() -> ::std::borrow::Cow<'static, str> {
                "DirectiveExecuted".into()
            }
            fn signature() -> ::ethers_core::types::H256 {
                ::ethers_core::types::H256([
                    71,
                    95,
                    210,
                    135,
                    153,
                    150,
                    230,
                    209,
                    98,
                    121,
                    89,
                    189,
                    150,
                    125,
                    138,
                    213,
                    175,
                    21,
                    69,
                    235,
                    115,
                    163,
                    2,
                    175,
                    119,
                    111,
                    241,
                    248,
                    230,
                    139,
                    94,
                    155,
                ])
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "DirectiveExecuted(uint256)".into()
            }
            fn decode_log(
                log: &::ethers_core::abi::RawLog,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
            where
                Self: Sized,
            {
                let ::ethers_core::abi::RawLog { data, topics } = log;
                let event_signature = topics
                    .get(0)
                    .ok_or(::ethers_core::abi::Error::InvalidData)?;
                if event_signature != &Self::signature() {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let topic_types = ::alloc::vec::Vec::new();
                let data_types = [::ethers_core::abi::ParamType::Uint(256usize)];
                let flat_topics = topics
                    .iter()
                    .skip(1)
                    .flat_map(|t| t.as_ref().to_vec())
                    .collect::<Vec<u8>>();
                let topic_tokens = ::ethers_core::abi::decode(
                    &topic_types,
                    &flat_topics,
                )?;
                if topic_tokens.len() != topics.len() - 1 {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
                let tokens: Vec<_> = topic_tokens
                    .into_iter()
                    .chain(data_tokens.into_iter())
                    .collect();
                ::ethers_core::abi::Tokenizable::from_token(
                        ::ethers_core::abi::Token::Tuple(tokens),
                    )
                    .map_err(|_| ::ethers_core::abi::Error::InvalidData)
            }
            fn is_anonymous() -> bool {
                false
            }
        }
        impl ::core::fmt::Display for DirectiveExecutedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Display::fmt(&self.seq, f)?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DirectiveExecutedFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "seq" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"seq" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DirectiveExecutedFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DirectiveExecutedFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DirectiveExecutedFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DirectiveExecutedFilter with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DirectiveExecutedFilter {
                                seq: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("seq")?
                                }
                            };
                            _serde::__private::Ok(DirectiveExecutedFilter {
                                seq: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["seq"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DirectiveExecutedFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DirectiveExecutedFilter,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DirectiveExecutedFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DirectiveExecutedFilter",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "seq",
                        &self.seq,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for DirectiveExecutedFilter {
            #[inline]
            fn default() -> DirectiveExecutedFilter {
                DirectiveExecutedFilter {
                    seq: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DirectiveExecutedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "DirectiveExecutedFilter",
                    "seq",
                    &&self.seq,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DirectiveExecutedFilter {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DirectiveExecutedFilter {
            #[inline]
            fn eq(&self, other: &DirectiveExecutedFilter) -> bool {
                self.seq == other.seq
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for DirectiveExecutedFilter {}
        #[automatically_derived]
        impl ::core::cmp::Eq for DirectiveExecutedFilter {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DirectiveExecutedFilter {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.seq, state)
            }
        }
        #[ethevent(
            name = "TokenBurned",
            abi = "TokenBurned(string,string,uint256,string)"
        )]
        pub struct TokenBurnedFilter {
            pub token_id: ::std::string::String,
            pub receiver: ::std::string::String,
            pub amount: ::ethers_core::types::U256,
            pub channel_id: ::std::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TokenBurnedFilter {
            #[inline]
            fn clone(&self) -> TokenBurnedFilter {
                TokenBurnedFilter {
                    token_id: ::core::clone::Clone::clone(&self.token_id),
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                    amount: ::core::clone::Clone::clone(&self.amount),
                    channel_id: ::core::clone::Clone::clone(&self.channel_id),
                }
            }
        }
        impl ::ethers_core::abi::AbiType for TokenBurnedFilter {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for TokenBurnedFilter {}
        impl ::ethers_core::abi::Tokenizable for TokenBurnedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 4usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 4 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        token_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        receiver: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        amount: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        channel_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.token_id.into_token(),
                            self.receiver.into_token(),
                            self.amount.into_token(),
                            self.channel_id.into_token(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for TokenBurnedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_contract::EthEvent for TokenBurnedFilter {
            fn name() -> ::std::borrow::Cow<'static, str> {
                "TokenBurned".into()
            }
            fn signature() -> ::ethers_core::types::H256 {
                ::ethers_core::types::H256([
                    176,
                    83,
                    180,
                    69,
                    38,
                    168,
                    90,
                    103,
                    204,
                    167,
                    33,
                    147,
                    104,
                    37,
                    80,
                    62,
                    55,
                    199,
                    204,
                    14,
                    26,
                    23,
                    81,
                    139,
                    247,
                    15,
                    99,
                    158,
                    22,
                    206,
                    65,
                    141,
                ])
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "TokenBurned(string,string,uint256,string)".into()
            }
            fn decode_log(
                log: &::ethers_core::abi::RawLog,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
            where
                Self: Sized,
            {
                let ::ethers_core::abi::RawLog { data, topics } = log;
                let event_signature = topics
                    .get(0)
                    .ok_or(::ethers_core::abi::Error::InvalidData)?;
                if event_signature != &Self::signature() {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let topic_types = ::alloc::vec::Vec::new();
                let data_types = [
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::String,
                ];
                let flat_topics = topics
                    .iter()
                    .skip(1)
                    .flat_map(|t| t.as_ref().to_vec())
                    .collect::<Vec<u8>>();
                let topic_tokens = ::ethers_core::abi::decode(
                    &topic_types,
                    &flat_topics,
                )?;
                if topic_tokens.len() != topics.len() - 1 {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
                let tokens: Vec<_> = topic_tokens
                    .into_iter()
                    .chain(data_tokens.into_iter())
                    .collect();
                ::ethers_core::abi::Tokenizable::from_token(
                        ::ethers_core::abi::Token::Tuple(tokens),
                    )
                    .map_err(|_| ::ethers_core::abi::Error::InvalidData)
            }
            fn is_anonymous() -> bool {
                false
            }
        }
        impl ::core::fmt::Display for TokenBurnedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Display::fmt(&self.token_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.receiver, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.amount, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.channel_id, f)?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TokenBurnedFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token_id" => _serde::__private::Ok(__Field::__field0),
                                "receiver" => _serde::__private::Ok(__Field::__field1),
                                "amount" => _serde::__private::Ok(__Field::__field2),
                                "channel_id" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token_id" => _serde::__private::Ok(__Field::__field0),
                                b"receiver" => _serde::__private::Ok(__Field::__field1),
                                b"amount" => _serde::__private::Ok(__Field::__field2),
                                b"channel_id" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TokenBurnedFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TokenBurnedFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TokenBurnedFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TokenBurnedFilter with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TokenBurnedFilter with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TokenBurnedFilter with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct TokenBurnedFilter with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TokenBurnedFilter {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                channel_id: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "receiver",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "channel_id",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("receiver")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("amount")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("channel_id")?
                                }
                            };
                            _serde::__private::Ok(TokenBurnedFilter {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                channel_id: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "token_id",
                        "receiver",
                        "amount",
                        "channel_id",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TokenBurnedFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TokenBurnedFilter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TokenBurnedFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TokenBurnedFilter",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token_id",
                        &self.token_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "receiver",
                        &self.receiver,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "amount",
                        &self.amount,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "channel_id",
                        &self.channel_id,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for TokenBurnedFilter {
            #[inline]
            fn default() -> TokenBurnedFilter {
                TokenBurnedFilter {
                    token_id: ::core::default::Default::default(),
                    receiver: ::core::default::Default::default(),
                    amount: ::core::default::Default::default(),
                    channel_id: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TokenBurnedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "TokenBurnedFilter",
                    "token_id",
                    &self.token_id,
                    "receiver",
                    &self.receiver,
                    "amount",
                    &self.amount,
                    "channel_id",
                    &&self.channel_id,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TokenBurnedFilter {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TokenBurnedFilter {
            #[inline]
            fn eq(&self, other: &TokenBurnedFilter) -> bool {
                self.token_id == other.token_id && self.receiver == other.receiver
                    && self.amount == other.amount && self.channel_id == other.channel_id
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for TokenBurnedFilter {}
        #[automatically_derived]
        impl ::core::cmp::Eq for TokenBurnedFilter {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TokenBurnedFilter {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.token_id, state);
                ::core::hash::Hash::hash(&self.receiver, state);
                ::core::hash::Hash::hash(&self.amount, state);
                ::core::hash::Hash::hash(&self.channel_id, state)
            }
        }
        #[ethevent(
            name = "TokenMinted",
            abi = "TokenMinted(string,address,uint256,uint256,string)"
        )]
        pub struct TokenMintedFilter {
            pub token_id: ::std::string::String,
            pub receiver: ::ethers_core::types::Address,
            pub amount: ::ethers_core::types::U256,
            pub ticket_id: ::ethers_core::types::U256,
            pub memo: ::std::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TokenMintedFilter {
            #[inline]
            fn clone(&self) -> TokenMintedFilter {
                TokenMintedFilter {
                    token_id: ::core::clone::Clone::clone(&self.token_id),
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                    amount: ::core::clone::Clone::clone(&self.amount),
                    ticket_id: ::core::clone::Clone::clone(&self.ticket_id),
                    memo: ::core::clone::Clone::clone(&self.memo),
                }
            }
        }
        impl ::ethers_core::abi::AbiType for TokenMintedFilter {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::Address as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for TokenMintedFilter {}
        impl ::ethers_core::abi::Tokenizable for TokenMintedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::Address: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 5usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 5 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        token_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        receiver: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        amount: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        ticket_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        memo: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.token_id.into_token(),
                            self.receiver.into_token(),
                            self.amount.into_token(),
                            self.ticket_id.into_token(),
                            self.memo.into_token(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for TokenMintedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::Address: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_contract::EthEvent for TokenMintedFilter {
            fn name() -> ::std::borrow::Cow<'static, str> {
                "TokenMinted".into()
            }
            fn signature() -> ::ethers_core::types::H256 {
                ::ethers_core::types::H256([
                    78,
                    133,
                    64,
                    218,
                    61,
                    166,
                    79,
                    89,
                    211,
                    164,
                    31,
                    224,
                    75,
                    243,
                    251,
                    232,
                    221,
                    62,
                    205,
                    174,
                    67,
                    129,
                    102,
                    176,
                    15,
                    34,
                    74,
                    205,
                    79,
                    99,
                    221,
                    21,
                ])
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "TokenMinted(string,address,uint256,uint256,string)".into()
            }
            fn decode_log(
                log: &::ethers_core::abi::RawLog,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
            where
                Self: Sized,
            {
                let ::ethers_core::abi::RawLog { data, topics } = log;
                let event_signature = topics
                    .get(0)
                    .ok_or(::ethers_core::abi::Error::InvalidData)?;
                if event_signature != &Self::signature() {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let topic_types = ::alloc::vec::Vec::new();
                let data_types = [
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::Address,
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::String,
                ];
                let flat_topics = topics
                    .iter()
                    .skip(1)
                    .flat_map(|t| t.as_ref().to_vec())
                    .collect::<Vec<u8>>();
                let topic_tokens = ::ethers_core::abi::decode(
                    &topic_types,
                    &flat_topics,
                )?;
                if topic_tokens.len() != topics.len() - 1 {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
                let tokens: Vec<_> = topic_tokens
                    .into_iter()
                    .chain(data_tokens.into_iter())
                    .collect();
                ::ethers_core::abi::Tokenizable::from_token(
                        ::ethers_core::abi::Token::Tuple(tokens),
                    )
                    .map_err(|_| ::ethers_core::abi::Error::InvalidData)
            }
            fn is_anonymous() -> bool {
                false
            }
        }
        impl ::core::fmt::Display for TokenMintedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Display::fmt(&self.token_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Debug::fmt(&self.receiver, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.amount, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.ticket_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.memo, f)?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TokenMintedFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token_id" => _serde::__private::Ok(__Field::__field0),
                                "receiver" => _serde::__private::Ok(__Field::__field1),
                                "amount" => _serde::__private::Ok(__Field::__field2),
                                "ticket_id" => _serde::__private::Ok(__Field::__field3),
                                "memo" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token_id" => _serde::__private::Ok(__Field::__field0),
                                b"receiver" => _serde::__private::Ok(__Field::__field1),
                                b"amount" => _serde::__private::Ok(__Field::__field2),
                                b"ticket_id" => _serde::__private::Ok(__Field::__field3),
                                b"memo" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TokenMintedFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TokenMintedFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TokenMintedFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TokenMintedFilter with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TokenMintedFilter with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TokenMintedFilter with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct TokenMintedFilter with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct TokenMintedFilter with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TokenMintedFilter {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                ticket_id: __field3,
                                memo: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::ethers_core::types::Address,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "receiver",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::Address,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "ticket_id",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("receiver")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("amount")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("ticket_id")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memo")?
                                }
                            };
                            _serde::__private::Ok(TokenMintedFilter {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                ticket_id: __field3,
                                memo: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "token_id",
                        "receiver",
                        "amount",
                        "ticket_id",
                        "memo",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TokenMintedFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TokenMintedFilter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TokenMintedFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TokenMintedFilter",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token_id",
                        &self.token_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "receiver",
                        &self.receiver,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "amount",
                        &self.amount,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ticket_id",
                        &self.ticket_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memo",
                        &self.memo,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for TokenMintedFilter {
            #[inline]
            fn default() -> TokenMintedFilter {
                TokenMintedFilter {
                    token_id: ::core::default::Default::default(),
                    receiver: ::core::default::Default::default(),
                    amount: ::core::default::Default::default(),
                    ticket_id: ::core::default::Default::default(),
                    memo: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TokenMintedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "TokenMintedFilter",
                    "token_id",
                    &self.token_id,
                    "receiver",
                    &self.receiver,
                    "amount",
                    &self.amount,
                    "ticket_id",
                    &self.ticket_id,
                    "memo",
                    &&self.memo,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TokenMintedFilter {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TokenMintedFilter {
            #[inline]
            fn eq(&self, other: &TokenMintedFilter) -> bool {
                self.token_id == other.token_id && self.receiver == other.receiver
                    && self.amount == other.amount && self.ticket_id == other.ticket_id
                    && self.memo == other.memo
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for TokenMintedFilter {}
        #[automatically_derived]
        impl ::core::cmp::Eq for TokenMintedFilter {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::Address>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TokenMintedFilter {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.token_id, state);
                ::core::hash::Hash::hash(&self.receiver, state);
                ::core::hash::Hash::hash(&self.amount, state);
                ::core::hash::Hash::hash(&self.ticket_id, state);
                ::core::hash::Hash::hash(&self.memo, state)
            }
        }
        #[ethevent(
            name = "TokenTransportRequested",
            abi = "TokenTransportRequested(string,string,string,uint256,string,string)"
        )]
        pub struct TokenTransportRequestedFilter {
            pub dst_chain_id: ::std::string::String,
            pub token_id: ::std::string::String,
            pub receiver: ::std::string::String,
            pub amount: ::ethers_core::types::U256,
            pub channel_id: ::std::string::String,
            pub memo: ::std::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TokenTransportRequestedFilter {
            #[inline]
            fn clone(&self) -> TokenTransportRequestedFilter {
                TokenTransportRequestedFilter {
                    dst_chain_id: ::core::clone::Clone::clone(&self.dst_chain_id),
                    token_id: ::core::clone::Clone::clone(&self.token_id),
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                    amount: ::core::clone::Clone::clone(&self.amount),
                    channel_id: ::core::clone::Clone::clone(&self.channel_id),
                    memo: ::core::clone::Clone::clone(&self.memo),
                }
            }
        }
        impl ::ethers_core::abi::AbiType for TokenTransportRequestedFilter {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for TokenTransportRequestedFilter {}
        impl ::ethers_core::abi::Tokenizable for TokenTransportRequestedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 6usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 6 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        dst_chain_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        token_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        receiver: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        amount: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        channel_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        memo: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.dst_chain_id.into_token(),
                            self.token_id.into_token(),
                            self.receiver.into_token(),
                            self.amount.into_token(),
                            self.channel_id.into_token(),
                            self.memo.into_token(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for TokenTransportRequestedFilter
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_contract::EthEvent for TokenTransportRequestedFilter {
            fn name() -> ::std::borrow::Cow<'static, str> {
                "TokenTransportRequested".into()
            }
            fn signature() -> ::ethers_core::types::H256 {
                ::ethers_core::types::H256([
                    42,
                    113,
                    67,
                    4,
                    159,
                    220,
                    34,
                    139,
                    33,
                    131,
                    92,
                    39,
                    231,
                    216,
                    181,
                    111,
                    135,
                    174,
                    7,
                    185,
                    45,
                    163,
                    25,
                    98,
                    234,
                    216,
                    111,
                    188,
                    255,
                    201,
                    119,
                    63,
                ])
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "TokenTransportRequested(string,string,string,uint256,string,string)"
                    .into()
            }
            fn decode_log(
                log: &::ethers_core::abi::RawLog,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
            where
                Self: Sized,
            {
                let ::ethers_core::abi::RawLog { data, topics } = log;
                let event_signature = topics
                    .get(0)
                    .ok_or(::ethers_core::abi::Error::InvalidData)?;
                if event_signature != &Self::signature() {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let topic_types = ::alloc::vec::Vec::new();
                let data_types = [
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::String,
                ];
                let flat_topics = topics
                    .iter()
                    .skip(1)
                    .flat_map(|t| t.as_ref().to_vec())
                    .collect::<Vec<u8>>();
                let topic_tokens = ::ethers_core::abi::decode(
                    &topic_types,
                    &flat_topics,
                )?;
                if topic_tokens.len() != topics.len() - 1 {
                    return Err(::ethers_core::abi::Error::InvalidData);
                }
                let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
                let tokens: Vec<_> = topic_tokens
                    .into_iter()
                    .chain(data_tokens.into_iter())
                    .collect();
                ::ethers_core::abi::Tokenizable::from_token(
                        ::ethers_core::abi::Token::Tuple(tokens),
                    )
                    .map_err(|_| ::ethers_core::abi::Error::InvalidData)
            }
            fn is_anonymous() -> bool {
                false
            }
        }
        impl ::core::fmt::Display for TokenTransportRequestedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Display::fmt(&self.dst_chain_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.token_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.receiver, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.amount, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.channel_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.memo, f)?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TokenTransportRequestedFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "dst_chain_id" => _serde::__private::Ok(__Field::__field0),
                                "token_id" => _serde::__private::Ok(__Field::__field1),
                                "receiver" => _serde::__private::Ok(__Field::__field2),
                                "amount" => _serde::__private::Ok(__Field::__field3),
                                "channel_id" => _serde::__private::Ok(__Field::__field4),
                                "memo" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"dst_chain_id" => _serde::__private::Ok(__Field::__field0),
                                b"token_id" => _serde::__private::Ok(__Field::__field1),
                                b"receiver" => _serde::__private::Ok(__Field::__field2),
                                b"amount" => _serde::__private::Ok(__Field::__field3),
                                b"channel_id" => _serde::__private::Ok(__Field::__field4),
                                b"memo" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            TokenTransportRequestedFilter,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TokenTransportRequestedFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TokenTransportRequestedFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct TokenTransportRequestedFilter with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TokenTransportRequestedFilter {
                                dst_chain_id: __field0,
                                token_id: __field1,
                                receiver: __field2,
                                amount: __field3,
                                channel_id: __field4,
                                memo: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dst_chain_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token_id",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "receiver",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "channel_id",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dst_chain_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token_id")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("receiver")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("amount")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("channel_id")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memo")?
                                }
                            };
                            _serde::__private::Ok(TokenTransportRequestedFilter {
                                dst_chain_id: __field0,
                                token_id: __field1,
                                receiver: __field2,
                                amount: __field3,
                                channel_id: __field4,
                                memo: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "dst_chain_id",
                        "token_id",
                        "receiver",
                        "amount",
                        "channel_id",
                        "memo",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TokenTransportRequestedFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TokenTransportRequestedFilter,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TokenTransportRequestedFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TokenTransportRequestedFilter",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dst_chain_id",
                        &self.dst_chain_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token_id",
                        &self.token_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "receiver",
                        &self.receiver,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "amount",
                        &self.amount,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "channel_id",
                        &self.channel_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memo",
                        &self.memo,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for TokenTransportRequestedFilter {
            #[inline]
            fn default() -> TokenTransportRequestedFilter {
                TokenTransportRequestedFilter {
                    dst_chain_id: ::core::default::Default::default(),
                    token_id: ::core::default::Default::default(),
                    receiver: ::core::default::Default::default(),
                    amount: ::core::default::Default::default(),
                    channel_id: ::core::default::Default::default(),
                    memo: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TokenTransportRequestedFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "dst_chain_id",
                    "token_id",
                    "receiver",
                    "amount",
                    "channel_id",
                    "memo",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.dst_chain_id,
                    &self.token_id,
                    &self.receiver,
                    &self.amount,
                    &self.channel_id,
                    &&self.memo,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "TokenTransportRequestedFilter",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TokenTransportRequestedFilter {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TokenTransportRequestedFilter {
            #[inline]
            fn eq(&self, other: &TokenTransportRequestedFilter) -> bool {
                self.dst_chain_id == other.dst_chain_id
                    && self.token_id == other.token_id && self.receiver == other.receiver
                    && self.amount == other.amount && self.channel_id == other.channel_id
                    && self.memo == other.memo
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for TokenTransportRequestedFilter {}
        #[automatically_derived]
        impl ::core::cmp::Eq for TokenTransportRequestedFilter {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TokenTransportRequestedFilter {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.dst_chain_id, state);
                ::core::hash::Hash::hash(&self.token_id, state);
                ::core::hash::Hash::hash(&self.receiver, state);
                ::core::hash::Hash::hash(&self.amount, state);
                ::core::hash::Hash::hash(&self.channel_id, state);
                ::core::hash::Hash::hash(&self.memo, state)
            }
        }
        ///Container type for all of the contract's events
        pub enum OmnityPortContractEvents {
            DirectiveExecutedFilter(DirectiveExecutedFilter),
            TokenBurnedFilter(TokenBurnedFilter),
            TokenMintedFilter(TokenMintedFilter),
            TokenTransportRequestedFilter(TokenTransportRequestedFilter),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OmnityPortContractEvents {
            #[inline]
            fn clone(&self) -> OmnityPortContractEvents {
                match self {
                    OmnityPortContractEvents::DirectiveExecutedFilter(__self_0) => {
                        OmnityPortContractEvents::DirectiveExecutedFilter(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    OmnityPortContractEvents::TokenBurnedFilter(__self_0) => {
                        OmnityPortContractEvents::TokenBurnedFilter(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    OmnityPortContractEvents::TokenMintedFilter(__self_0) => {
                        OmnityPortContractEvents::TokenMintedFilter(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    OmnityPortContractEvents::TokenTransportRequestedFilter(__self_0) => {
                        OmnityPortContractEvents::TokenTransportRequestedFilter(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        impl ::ethers_core::abi::Tokenizable for OmnityPortContractEvents {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(
                    token.clone(),
                ) {
                    return Ok(
                        OmnityPortContractEvents::DirectiveExecutedFilter(decoded),
                    );
                }
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(
                    token.clone(),
                ) {
                    return Ok(OmnityPortContractEvents::TokenBurnedFilter(decoded));
                }
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(
                    token.clone(),
                ) {
                    return Ok(OmnityPortContractEvents::TokenMintedFilter(decoded));
                }
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(token) {
                    return Ok(
                        OmnityPortContractEvents::TokenTransportRequestedFilter(decoded),
                    );
                }
                Err(
                    ::ethers_core::abi::InvalidOutputType(
                        "Failed to decode all type variants".to_string(),
                    ),
                )
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                match self {
                    OmnityPortContractEvents::DirectiveExecutedFilter(element) => {
                        element.into_token()
                    }
                    OmnityPortContractEvents::TokenBurnedFilter(element) => {
                        element.into_token()
                    }
                    OmnityPortContractEvents::TokenMintedFilter(element) => {
                        element.into_token()
                    }
                    OmnityPortContractEvents::TokenTransportRequestedFilter(element) => {
                        element.into_token()
                    }
                }
            }
        }
        impl ::ethers_core::abi::TokenizableItem for OmnityPortContractEvents {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OmnityPortContractEvents {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "DirectiveExecutedFilter" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "TokenBurnedFilter" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "TokenMintedFilter" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "TokenTransportRequestedFilter" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"DirectiveExecutedFilter" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"TokenBurnedFilter" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"TokenMintedFilter" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"TokenTransportRequestedFilter" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OmnityPortContractEvents>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OmnityPortContractEvents;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum OmnityPortContractEvents",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            DirectiveExecutedFilter,
                                        >(__variant),
                                        OmnityPortContractEvents::DirectiveExecutedFilter,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            TokenBurnedFilter,
                                        >(__variant),
                                        OmnityPortContractEvents::TokenBurnedFilter,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            TokenMintedFilter,
                                        >(__variant),
                                        OmnityPortContractEvents::TokenMintedFilter,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            TokenTransportRequestedFilter,
                                        >(__variant),
                                        OmnityPortContractEvents::TokenTransportRequestedFilter,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "DirectiveExecutedFilter",
                        "TokenBurnedFilter",
                        "TokenMintedFilter",
                        "TokenTransportRequestedFilter",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "OmnityPortContractEvents",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OmnityPortContractEvents,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OmnityPortContractEvents {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        OmnityPortContractEvents::DirectiveExecutedFilter(
                            ref __field0,
                        ) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractEvents",
                                0u32,
                                "DirectiveExecutedFilter",
                                __field0,
                            )
                        }
                        OmnityPortContractEvents::TokenBurnedFilter(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractEvents",
                                1u32,
                                "TokenBurnedFilter",
                                __field0,
                            )
                        }
                        OmnityPortContractEvents::TokenMintedFilter(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractEvents",
                                2u32,
                                "TokenMintedFilter",
                                __field0,
                            )
                        }
                        OmnityPortContractEvents::TokenTransportRequestedFilter(
                            ref __field0,
                        ) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractEvents",
                                3u32,
                                "TokenTransportRequestedFilter",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OmnityPortContractEvents {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    OmnityPortContractEvents::DirectiveExecutedFilter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "DirectiveExecutedFilter",
                            &__self_0,
                        )
                    }
                    OmnityPortContractEvents::TokenBurnedFilter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TokenBurnedFilter",
                            &__self_0,
                        )
                    }
                    OmnityPortContractEvents::TokenMintedFilter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TokenMintedFilter",
                            &__self_0,
                        )
                    }
                    OmnityPortContractEvents::TokenTransportRequestedFilter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TokenTransportRequestedFilter",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OmnityPortContractEvents {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OmnityPortContractEvents {
            #[inline]
            fn eq(&self, other: &OmnityPortContractEvents) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            OmnityPortContractEvents::DirectiveExecutedFilter(__self_0),
                            OmnityPortContractEvents::DirectiveExecutedFilter(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            OmnityPortContractEvents::TokenBurnedFilter(__self_0),
                            OmnityPortContractEvents::TokenBurnedFilter(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            OmnityPortContractEvents::TokenMintedFilter(__self_0),
                            OmnityPortContractEvents::TokenMintedFilter(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            OmnityPortContractEvents::TokenTransportRequestedFilter(
                                __self_0,
                            ),
                            OmnityPortContractEvents::TokenTransportRequestedFilter(
                                __arg1_0,
                            ),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for OmnityPortContractEvents {}
        #[automatically_derived]
        impl ::core::cmp::Eq for OmnityPortContractEvents {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<DirectiveExecutedFilter>;
                let _: ::core::cmp::AssertParamIsEq<TokenBurnedFilter>;
                let _: ::core::cmp::AssertParamIsEq<TokenMintedFilter>;
                let _: ::core::cmp::AssertParamIsEq<TokenTransportRequestedFilter>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OmnityPortContractEvents {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    OmnityPortContractEvents::DirectiveExecutedFilter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    OmnityPortContractEvents::TokenBurnedFilter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    OmnityPortContractEvents::TokenMintedFilter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    OmnityPortContractEvents::TokenTransportRequestedFilter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl ::ethers_contract::EthLogDecode for OmnityPortContractEvents {
            fn decode_log(
                log: &::ethers_core::abi::RawLog,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::Error> {
                if let Ok(decoded) = DirectiveExecutedFilter::decode_log(log) {
                    return Ok(
                        OmnityPortContractEvents::DirectiveExecutedFilter(decoded),
                    );
                }
                if let Ok(decoded) = TokenBurnedFilter::decode_log(log) {
                    return Ok(OmnityPortContractEvents::TokenBurnedFilter(decoded));
                }
                if let Ok(decoded) = TokenMintedFilter::decode_log(log) {
                    return Ok(OmnityPortContractEvents::TokenMintedFilter(decoded));
                }
                if let Ok(decoded) = TokenTransportRequestedFilter::decode_log(log) {
                    return Ok(
                        OmnityPortContractEvents::TokenTransportRequestedFilter(decoded),
                    );
                }
                Err(::ethers_core::abi::Error::InvalidData)
            }
        }
        impl ::core::fmt::Display for OmnityPortContractEvents {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                match self {
                    Self::DirectiveExecutedFilter(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                    Self::TokenBurnedFilter(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                    Self::TokenMintedFilter(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                    Self::TokenTransportRequestedFilter(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                }
            }
        }
        impl ::core::convert::From<DirectiveExecutedFilter>
        for OmnityPortContractEvents {
            fn from(value: DirectiveExecutedFilter) -> Self {
                Self::DirectiveExecutedFilter(value)
            }
        }
        impl ::core::convert::From<TokenBurnedFilter> for OmnityPortContractEvents {
            fn from(value: TokenBurnedFilter) -> Self {
                Self::TokenBurnedFilter(value)
            }
        }
        impl ::core::convert::From<TokenMintedFilter> for OmnityPortContractEvents {
            fn from(value: TokenMintedFilter) -> Self {
                Self::TokenMintedFilter(value)
            }
        }
        impl ::core::convert::From<TokenTransportRequestedFilter>
        for OmnityPortContractEvents {
            fn from(value: TokenTransportRequestedFilter) -> Self {
                Self::TokenTransportRequestedFilter(value)
            }
        }
        ///Container type for all input parameters for the `privilegedExecuteDirective` function with signature `privilegedExecuteDirective(bytes)` and selector `0x77b91045`
        #[ethcall(
            name = "privilegedExecuteDirective",
            abi = "privilegedExecuteDirective(bytes)"
        )]
        pub struct PrivilegedExecuteDirectiveCall {
            pub directive_bytes: ::ethers_core::types::Bytes,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PrivilegedExecuteDirectiveCall {
            #[inline]
            fn clone(&self) -> PrivilegedExecuteDirectiveCall {
                PrivilegedExecuteDirectiveCall {
                    directive_bytes: ::core::clone::Clone::clone(&self.directive_bytes),
                }
            }
        }
        impl ::ethers_contract::EthCall for PrivilegedExecuteDirectiveCall {
            fn function_name() -> ::std::borrow::Cow<'static, str> {
                "privilegedExecuteDirective".into()
            }
            fn selector() -> ::ethers_core::types::Selector {
                [119, 185, 16, 69]
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "privilegedExecuteDirective(bytes)".into()
            }
        }
        impl ::ethers_core::abi::AbiType for PrivilegedExecuteDirectiveCall {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::ethers_core::types::Bytes as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for PrivilegedExecuteDirectiveCall {}
        impl ::ethers_core::abi::Tokenizable for PrivilegedExecuteDirectiveCall
        where
            ::ethers_core::types::Bytes: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 1usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 1 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        directive_bytes: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([self.directive_bytes.into_token()]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for PrivilegedExecuteDirectiveCall
        where
            ::ethers_core::types::Bytes: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_core::abi::AbiDecode for PrivilegedExecuteDirectiveCall {
            fn decode(
                bytes: impl AsRef<[u8]>,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::AbiError> {
                let bytes = bytes.as_ref();
                if bytes.len() < 4
                    || bytes[..4] != <Self as ::ethers_contract::EthCall>::selector()
                {
                    return Err(::ethers_contract::AbiError::WrongSelector);
                }
                let data_types = [::ethers_core::abi::ParamType::Bytes];
                let data_tokens = ::ethers_core::abi::decode(&data_types, &bytes[4..])?;
                Ok(
                    <Self as ::ethers_core::abi::Tokenizable>::from_token(
                        ::ethers_core::abi::Token::Tuple(data_tokens),
                    )?,
                )
            }
        }
        impl ::ethers_core::abi::AbiEncode for PrivilegedExecuteDirectiveCall {
            fn encode(self) -> ::std::vec::Vec<u8> {
                let tokens = ::ethers_core::abi::Tokenize::into_tokens(self);
                let selector = <Self as ::ethers_contract::EthCall>::selector();
                let encoded = ::ethers_core::abi::encode(&tokens);
                selector.iter().copied().chain(encoded.into_iter()).collect()
            }
        }
        impl ::core::fmt::Display for PrivilegedExecuteDirectiveCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Write::write_str(f, "0x")?;
                ::core::fmt::Write::write_str(
                    f,
                    ::ethers_core::utils::hex::encode(&self.directive_bytes).as_str(),
                )?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PrivilegedExecuteDirectiveCall {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "directive_bytes" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"directive_bytes" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            PrivilegedExecuteDirectiveCall,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PrivilegedExecuteDirectiveCall;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PrivilegedExecuteDirectiveCall",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::Bytes,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PrivilegedExecuteDirectiveCall with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PrivilegedExecuteDirectiveCall {
                                directive_bytes: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::ethers_core::types::Bytes,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "directive_bytes",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::Bytes,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("directive_bytes")?
                                }
                            };
                            _serde::__private::Ok(PrivilegedExecuteDirectiveCall {
                                directive_bytes: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["directive_bytes"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PrivilegedExecuteDirectiveCall",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PrivilegedExecuteDirectiveCall,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PrivilegedExecuteDirectiveCall {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PrivilegedExecuteDirectiveCall",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "directive_bytes",
                        &self.directive_bytes,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for PrivilegedExecuteDirectiveCall {
            #[inline]
            fn default() -> PrivilegedExecuteDirectiveCall {
                PrivilegedExecuteDirectiveCall {
                    directive_bytes: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PrivilegedExecuteDirectiveCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "PrivilegedExecuteDirectiveCall",
                    "directive_bytes",
                    &&self.directive_bytes,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PrivilegedExecuteDirectiveCall {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PrivilegedExecuteDirectiveCall {
            #[inline]
            fn eq(&self, other: &PrivilegedExecuteDirectiveCall) -> bool {
                self.directive_bytes == other.directive_bytes
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for PrivilegedExecuteDirectiveCall {}
        #[automatically_derived]
        impl ::core::cmp::Eq for PrivilegedExecuteDirectiveCall {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::Bytes>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PrivilegedExecuteDirectiveCall {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.directive_bytes, state)
            }
        }
        ///Container type for all input parameters for the `privilegedMintToken` function with signature `privilegedMintToken(string,address,uint256,uint256,string)` and selector `0x582fd22d`
        #[ethcall(
            name = "privilegedMintToken",
            abi = "privilegedMintToken(string,address,uint256,uint256,string)"
        )]
        pub struct PrivilegedMintTokenCall {
            pub token_id: ::std::string::String,
            pub receiver: ::ethers_core::types::Address,
            pub amount: ::ethers_core::types::U256,
            pub ticket_id: ::ethers_core::types::U256,
            pub memo: ::std::string::String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PrivilegedMintTokenCall {
            #[inline]
            fn clone(&self) -> PrivilegedMintTokenCall {
                PrivilegedMintTokenCall {
                    token_id: ::core::clone::Clone::clone(&self.token_id),
                    receiver: ::core::clone::Clone::clone(&self.receiver),
                    amount: ::core::clone::Clone::clone(&self.amount),
                    ticket_id: ::core::clone::Clone::clone(&self.ticket_id),
                    memo: ::core::clone::Clone::clone(&self.memo),
                }
            }
        }
        impl ::ethers_contract::EthCall for PrivilegedMintTokenCall {
            fn function_name() -> ::std::borrow::Cow<'static, str> {
                "privilegedMintToken".into()
            }
            fn selector() -> ::ethers_core::types::Selector {
                [88, 47, 210, 45]
            }
            fn abi_signature() -> ::std::borrow::Cow<'static, str> {
                "privilegedMintToken(string,address,uint256,uint256,string)".into()
            }
        }
        impl ::ethers_core::abi::AbiType for PrivilegedMintTokenCall {
            fn param_type() -> ::ethers_core::abi::ParamType {
                ::ethers_core::abi::ParamType::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::Address as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::ethers_core::types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                            <::std::string::String as ::ethers_core::abi::AbiType>::param_type(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::AbiArrayType for PrivilegedMintTokenCall {}
        impl ::ethers_core::abi::Tokenizable for PrivilegedMintTokenCall
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::Address: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                    if tokens.len() != 5usize {
                        return Err(
                            ::ethers_core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expected 5 tokens, got {0}: {1:?}",
                                        tokens.len(),
                                        tokens,
                                    ),
                                );
                                res
                            }),
                        );
                    }
                    let mut iter = tokens.into_iter();
                    Ok(Self {
                        token_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        receiver: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        amount: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        ticket_id: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                        memo: ::ethers_core::abi::Tokenizable::from_token(
                            iter
                                .next()
                                .expect(
                                    "The iter is guaranteed to be something due to the size check",
                                ),
                        )?,
                    })
                } else {
                    Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!("Expected Tuple, got {0:?}", token),
                            );
                            res
                        }),
                    )
                }
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                ::ethers_core::abi::Token::Tuple(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            self.token_id.into_token(),
                            self.receiver.into_token(),
                            self.amount.into_token(),
                            self.ticket_id.into_token(),
                            self.memo.into_token(),
                        ]),
                    ),
                )
            }
        }
        impl ::ethers_core::abi::TokenizableItem for PrivilegedMintTokenCall
        where
            ::std::string::String: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::Address: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::ethers_core::types::U256: ::ethers_core::abi::Tokenize,
            ::std::string::String: ::ethers_core::abi::Tokenize,
        {}
        impl ::ethers_core::abi::AbiDecode for PrivilegedMintTokenCall {
            fn decode(
                bytes: impl AsRef<[u8]>,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::AbiError> {
                let bytes = bytes.as_ref();
                if bytes.len() < 4
                    || bytes[..4] != <Self as ::ethers_contract::EthCall>::selector()
                {
                    return Err(::ethers_contract::AbiError::WrongSelector);
                }
                let data_types = [
                    ::ethers_core::abi::ParamType::String,
                    ::ethers_core::abi::ParamType::Address,
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::Uint(256usize),
                    ::ethers_core::abi::ParamType::String,
                ];
                let data_tokens = ::ethers_core::abi::decode(&data_types, &bytes[4..])?;
                Ok(
                    <Self as ::ethers_core::abi::Tokenizable>::from_token(
                        ::ethers_core::abi::Token::Tuple(data_tokens),
                    )?,
                )
            }
        }
        impl ::ethers_core::abi::AbiEncode for PrivilegedMintTokenCall {
            fn encode(self) -> ::std::vec::Vec<u8> {
                let tokens = ::ethers_core::abi::Tokenize::into_tokens(self);
                let selector = <Self as ::ethers_contract::EthCall>::selector();
                let encoded = ::ethers_core::abi::encode(&tokens);
                selector.iter().copied().chain(encoded.into_iter()).collect()
            }
        }
        impl ::core::fmt::Display for PrivilegedMintTokenCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                ::core::fmt::Display::fmt(&self.token_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Debug::fmt(&self.receiver, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.amount, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.ticket_id, f)?;
                ::core::fmt::Write::write_str(f, ", ")?;
                ::core::fmt::Display::fmt(&self.memo, f)?;
                Ok(())
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PrivilegedMintTokenCall {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "token_id" => _serde::__private::Ok(__Field::__field0),
                                "receiver" => _serde::__private::Ok(__Field::__field1),
                                "amount" => _serde::__private::Ok(__Field::__field2),
                                "ticket_id" => _serde::__private::Ok(__Field::__field3),
                                "memo" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"token_id" => _serde::__private::Ok(__Field::__field0),
                                b"receiver" => _serde::__private::Ok(__Field::__field1),
                                b"amount" => _serde::__private::Ok(__Field::__field2),
                                b"ticket_id" => _serde::__private::Ok(__Field::__field3),
                                b"memo" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PrivilegedMintTokenCall>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PrivilegedMintTokenCall;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PrivilegedMintTokenCall",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PrivilegedMintTokenCall with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PrivilegedMintTokenCall with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PrivilegedMintTokenCall with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                ::ethers_core::types::U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct PrivilegedMintTokenCall with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                ::std::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct PrivilegedMintTokenCall with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PrivilegedMintTokenCall {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                ticket_id: __field3,
                                memo: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::ethers_core::types::Address,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                ::ethers_core::types::U256,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                ::std::string::String,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "receiver",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::Address,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "ticket_id",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::ethers_core::types::U256,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::std::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("receiver")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("amount")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("ticket_id")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memo")?
                                }
                            };
                            _serde::__private::Ok(PrivilegedMintTokenCall {
                                token_id: __field0,
                                receiver: __field1,
                                amount: __field2,
                                ticket_id: __field3,
                                memo: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "token_id",
                        "receiver",
                        "amount",
                        "ticket_id",
                        "memo",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PrivilegedMintTokenCall",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PrivilegedMintTokenCall,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PrivilegedMintTokenCall {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PrivilegedMintTokenCall",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token_id",
                        &self.token_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "receiver",
                        &self.receiver,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "amount",
                        &self.amount,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ticket_id",
                        &self.ticket_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memo",
                        &self.memo,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for PrivilegedMintTokenCall {
            #[inline]
            fn default() -> PrivilegedMintTokenCall {
                PrivilegedMintTokenCall {
                    token_id: ::core::default::Default::default(),
                    receiver: ::core::default::Default::default(),
                    amount: ::core::default::Default::default(),
                    ticket_id: ::core::default::Default::default(),
                    memo: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PrivilegedMintTokenCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "PrivilegedMintTokenCall",
                    "token_id",
                    &self.token_id,
                    "receiver",
                    &self.receiver,
                    "amount",
                    &self.amount,
                    "ticket_id",
                    &self.ticket_id,
                    "memo",
                    &&self.memo,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PrivilegedMintTokenCall {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PrivilegedMintTokenCall {
            #[inline]
            fn eq(&self, other: &PrivilegedMintTokenCall) -> bool {
                self.token_id == other.token_id && self.receiver == other.receiver
                    && self.amount == other.amount && self.ticket_id == other.ticket_id
                    && self.memo == other.memo
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for PrivilegedMintTokenCall {}
        #[automatically_derived]
        impl ::core::cmp::Eq for PrivilegedMintTokenCall {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::Address>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::ethers_core::types::U256>;
                let _: ::core::cmp::AssertParamIsEq<::std::string::String>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PrivilegedMintTokenCall {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.token_id, state);
                ::core::hash::Hash::hash(&self.receiver, state);
                ::core::hash::Hash::hash(&self.amount, state);
                ::core::hash::Hash::hash(&self.ticket_id, state);
                ::core::hash::Hash::hash(&self.memo, state)
            }
        }
        ///Container type for all of the contract's call
        pub enum OmnityPortContractCalls {
            PrivilegedExecuteDirective(PrivilegedExecuteDirectiveCall),
            PrivilegedMintToken(PrivilegedMintTokenCall),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OmnityPortContractCalls {
            #[inline]
            fn clone(&self) -> OmnityPortContractCalls {
                match self {
                    OmnityPortContractCalls::PrivilegedExecuteDirective(__self_0) => {
                        OmnityPortContractCalls::PrivilegedExecuteDirective(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    OmnityPortContractCalls::PrivilegedMintToken(__self_0) => {
                        OmnityPortContractCalls::PrivilegedMintToken(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        impl ::ethers_core::abi::Tokenizable for OmnityPortContractCalls {
            fn from_token(
                token: ::ethers_core::abi::Token,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(
                    token.clone(),
                ) {
                    return Ok(
                        OmnityPortContractCalls::PrivilegedExecuteDirective(decoded),
                    );
                }
                if let Ok(decoded) = ::ethers_core::abi::Tokenizable::from_token(token) {
                    return Ok(OmnityPortContractCalls::PrivilegedMintToken(decoded));
                }
                Err(
                    ::ethers_core::abi::InvalidOutputType(
                        "Failed to decode all type variants".to_string(),
                    ),
                )
            }
            fn into_token(self) -> ::ethers_core::abi::Token {
                match self {
                    OmnityPortContractCalls::PrivilegedExecuteDirective(element) => {
                        element.into_token()
                    }
                    OmnityPortContractCalls::PrivilegedMintToken(element) => {
                        element.into_token()
                    }
                }
            }
        }
        impl ::ethers_core::abi::TokenizableItem for OmnityPortContractCalls {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OmnityPortContractCalls {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "PrivilegedExecuteDirective" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "PrivilegedMintToken" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"PrivilegedExecuteDirective" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"PrivilegedMintToken" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<OmnityPortContractCalls>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OmnityPortContractCalls;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum OmnityPortContractCalls",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            PrivilegedExecuteDirectiveCall,
                                        >(__variant),
                                        OmnityPortContractCalls::PrivilegedExecuteDirective,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            PrivilegedMintTokenCall,
                                        >(__variant),
                                        OmnityPortContractCalls::PrivilegedMintToken,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "PrivilegedExecuteDirective",
                        "PrivilegedMintToken",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "OmnityPortContractCalls",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                OmnityPortContractCalls,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OmnityPortContractCalls {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        OmnityPortContractCalls::PrivilegedExecuteDirective(
                            ref __field0,
                        ) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractCalls",
                                0u32,
                                "PrivilegedExecuteDirective",
                                __field0,
                            )
                        }
                        OmnityPortContractCalls::PrivilegedMintToken(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "OmnityPortContractCalls",
                                1u32,
                                "PrivilegedMintToken",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for OmnityPortContractCalls {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    OmnityPortContractCalls::PrivilegedExecuteDirective(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PrivilegedExecuteDirective",
                            &__self_0,
                        )
                    }
                    OmnityPortContractCalls::PrivilegedMintToken(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PrivilegedMintToken",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OmnityPortContractCalls {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OmnityPortContractCalls {
            #[inline]
            fn eq(&self, other: &OmnityPortContractCalls) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            OmnityPortContractCalls::PrivilegedExecuteDirective(
                                __self_0,
                            ),
                            OmnityPortContractCalls::PrivilegedExecuteDirective(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            OmnityPortContractCalls::PrivilegedMintToken(__self_0),
                            OmnityPortContractCalls::PrivilegedMintToken(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for OmnityPortContractCalls {}
        #[automatically_derived]
        impl ::core::cmp::Eq for OmnityPortContractCalls {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PrivilegedExecuteDirectiveCall>;
                let _: ::core::cmp::AssertParamIsEq<PrivilegedMintTokenCall>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for OmnityPortContractCalls {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    OmnityPortContractCalls::PrivilegedExecuteDirective(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    OmnityPortContractCalls::PrivilegedMintToken(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl ::ethers_core::abi::AbiDecode for OmnityPortContractCalls {
            fn decode(
                data: impl AsRef<[u8]>,
            ) -> ::core::result::Result<Self, ::ethers_core::abi::AbiError> {
                let data = data.as_ref();
                if let Ok(decoded) = <PrivilegedExecuteDirectiveCall as ::ethers_core::abi::AbiDecode>::decode(
                    data,
                ) {
                    return Ok(Self::PrivilegedExecuteDirective(decoded));
                }
                if let Ok(decoded) = <PrivilegedMintTokenCall as ::ethers_core::abi::AbiDecode>::decode(
                    data,
                ) {
                    return Ok(Self::PrivilegedMintToken(decoded));
                }
                Err(::ethers_core::abi::Error::InvalidData.into())
            }
        }
        impl ::ethers_core::abi::AbiEncode for OmnityPortContractCalls {
            fn encode(self) -> Vec<u8> {
                match self {
                    Self::PrivilegedExecuteDirective(element) => {
                        ::ethers_core::abi::AbiEncode::encode(element)
                    }
                    Self::PrivilegedMintToken(element) => {
                        ::ethers_core::abi::AbiEncode::encode(element)
                    }
                }
            }
        }
        impl ::core::fmt::Display for OmnityPortContractCalls {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                match self {
                    Self::PrivilegedExecuteDirective(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                    Self::PrivilegedMintToken(element) => {
                        ::core::fmt::Display::fmt(element, f)
                    }
                }
            }
        }
        impl ::core::convert::From<PrivilegedExecuteDirectiveCall>
        for OmnityPortContractCalls {
            fn from(value: PrivilegedExecuteDirectiveCall) -> Self {
                Self::PrivilegedExecuteDirective(value)
            }
        }
        impl ::core::convert::From<PrivilegedMintTokenCall> for OmnityPortContractCalls {
            fn from(value: PrivilegedMintTokenCall) -> Self {
                Self::PrivilegedMintToken(value)
            }
        }
    }
    pub struct TokenMinted {
        pub token_id: String,
        pub receiver: ethereum_types::Address,
        pub amount: U256,
        pub ticket_id: U256,
        pub memo: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenMinted {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "TokenMinted",
                "token_id",
                &self.token_id,
                "receiver",
                &self.receiver,
                "amount",
                &self.amount,
                "ticket_id",
                &self.ticket_id,
                "memo",
                &&self.memo,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenMinted {
        #[inline]
        fn clone(&self) -> TokenMinted {
            TokenMinted {
                token_id: ::core::clone::Clone::clone(&self.token_id),
                receiver: ::core::clone::Clone::clone(&self.receiver),
                amount: ::core::clone::Clone::clone(&self.amount),
                ticket_id: ::core::clone::Clone::clone(&self.ticket_id),
                memo: ::core::clone::Clone::clone(&self.memo),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenMinted {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenMinted",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "receiver",
                    &self.receiver,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ticket_id",
                    &self.ticket_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memo",
                    &self.memo,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenMinted {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "receiver" => _serde::__private::Ok(__Field::__field1),
                            "amount" => _serde::__private::Ok(__Field::__field2),
                            "ticket_id" => _serde::__private::Ok(__Field::__field3),
                            "memo" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"receiver" => _serde::__private::Ok(__Field::__field1),
                            b"amount" => _serde::__private::Ok(__Field::__field2),
                            b"ticket_id" => _serde::__private::Ok(__Field::__field3),
                            b"memo" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TokenMinted>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenMinted;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TokenMinted",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TokenMinted with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ethereum_types::Address,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenMinted with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            U256,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TokenMinted with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            U256,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TokenMinted with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TokenMinted with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TokenMinted {
                            token_id: __field0,
                            receiver: __field1,
                            amount: __field2,
                            ticket_id: __field3,
                            memo: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ethereum_types::Address,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<U256> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<U256> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "receiver",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ethereum_types::Address,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ticket_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("receiver")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ticket_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("memo")?
                            }
                        };
                        _serde::__private::Ok(TokenMinted {
                            token_id: __field0,
                            receiver: __field1,
                            amount: __field2,
                            ticket_id: __field3,
                            memo: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "receiver",
                    "amount",
                    "ticket_id",
                    "memo",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenMinted",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TokenMinted>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::ethers_core::abi::AbiType for TokenMinted {
        fn param_type() -> ::ethers_core::abi::ParamType {
            ::ethers_core::abi::ParamType::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <ethereum_types::Address as ::ethers_core::abi::AbiType>::param_type(),
                        <U256 as ::ethers_core::abi::AbiType>::param_type(),
                        <U256 as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::AbiArrayType for TokenMinted {}
    impl ::ethers_core::abi::Tokenizable for TokenMinted
    where
        String: ::ethers_core::abi::Tokenize,
        ethereum_types::Address: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {
        fn from_token(
            token: ::ethers_core::abi::Token,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
            if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                if tokens.len() != 5usize {
                    return Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Expected 5 tokens, got {0}: {1:?}",
                                    tokens.len(),
                                    tokens,
                                ),
                            );
                            res
                        }),
                    );
                }
                let mut iter = tokens.into_iter();
                Ok(Self {
                    token_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    receiver: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    amount: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    ticket_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    memo: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                })
            } else {
                Err(
                    ::ethers_core::abi::InvalidOutputType({
                        let res = ::alloc::fmt::format(
                            format_args!("Expected Tuple, got {0:?}", token),
                        );
                        res
                    }),
                )
            }
        }
        fn into_token(self) -> ::ethers_core::abi::Token {
            ::ethers_core::abi::Token::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        self.token_id.into_token(),
                        self.receiver.into_token(),
                        self.amount.into_token(),
                        self.ticket_id.into_token(),
                        self.memo.into_token(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::TokenizableItem for TokenMinted
    where
        String: ::ethers_core::abi::Tokenize,
        ethereum_types::Address: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {}
    impl ::ethers_contract::EthEvent for TokenMinted {
        fn name() -> ::std::borrow::Cow<'static, str> {
            "TokenMinted".into()
        }
        fn signature() -> ::ethers_core::types::H256 {
            ::ethers_core::types::H256([
                78,
                133,
                64,
                218,
                61,
                166,
                79,
                89,
                211,
                164,
                31,
                224,
                75,
                243,
                251,
                232,
                221,
                62,
                205,
                174,
                67,
                129,
                102,
                176,
                15,
                34,
                74,
                205,
                79,
                99,
                221,
                21,
            ])
        }
        fn abi_signature() -> ::std::borrow::Cow<'static, str> {
            "TokenMinted(string,address,uint256,uint256,string)".into()
        }
        fn decode_log(
            log: &::ethers_core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
        where
            Self: Sized,
        {
            let ::ethers_core::abi::RawLog { data, topics } = log;
            let event_signature = topics
                .get(0)
                .ok_or(::ethers_core::abi::Error::InvalidData)?;
            if event_signature != &Self::signature() {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let topic_types = ::alloc::vec::Vec::new();
            let data_types = [
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::Address,
                ::ethers_core::abi::ParamType::Uint(256usize),
                ::ethers_core::abi::ParamType::Uint(256usize),
                ::ethers_core::abi::ParamType::String,
            ];
            let flat_topics = topics
                .iter()
                .skip(1)
                .flat_map(|t| t.as_ref().to_vec())
                .collect::<Vec<u8>>();
            let topic_tokens = ::ethers_core::abi::decode(&topic_types, &flat_topics)?;
            if topic_tokens.len() != topics.len() - 1 {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
            let tokens: Vec<_> = topic_tokens
                .into_iter()
                .chain(data_tokens.into_iter())
                .collect();
            ::ethers_core::abi::Tokenizable::from_token(
                    ::ethers_core::abi::Token::Tuple(tokens),
                )
                .map_err(|_| ::ethers_core::abi::Error::InvalidData)
        }
        fn is_anonymous() -> bool {
            false
        }
    }
    pub struct TokenTransportRequested {
        pub dst_chain_id: String,
        pub token_id: String,
        pub receiver: String,
        pub amount: U256,
        pub channel_id: String,
        pub memo: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenTransportRequested {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "dst_chain_id",
                "token_id",
                "receiver",
                "amount",
                "channel_id",
                "memo",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.dst_chain_id,
                &self.token_id,
                &self.receiver,
                &self.amount,
                &self.channel_id,
                &&self.memo,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TokenTransportRequested",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenTransportRequested {
        #[inline]
        fn clone(&self) -> TokenTransportRequested {
            TokenTransportRequested {
                dst_chain_id: ::core::clone::Clone::clone(&self.dst_chain_id),
                token_id: ::core::clone::Clone::clone(&self.token_id),
                receiver: ::core::clone::Clone::clone(&self.receiver),
                amount: ::core::clone::Clone::clone(&self.amount),
                channel_id: ::core::clone::Clone::clone(&self.channel_id),
                memo: ::core::clone::Clone::clone(&self.memo),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenTransportRequested {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenTransportRequested",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dst_chain_id",
                    &self.dst_chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "receiver",
                    &self.receiver,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "channel_id",
                    &self.channel_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memo",
                    &self.memo,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenTransportRequested {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "dst_chain_id" => _serde::__private::Ok(__Field::__field0),
                            "token_id" => _serde::__private::Ok(__Field::__field1),
                            "receiver" => _serde::__private::Ok(__Field::__field2),
                            "amount" => _serde::__private::Ok(__Field::__field3),
                            "channel_id" => _serde::__private::Ok(__Field::__field4),
                            "memo" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"dst_chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                            b"receiver" => _serde::__private::Ok(__Field::__field2),
                            b"amount" => _serde::__private::Ok(__Field::__field3),
                            b"channel_id" => _serde::__private::Ok(__Field::__field4),
                            b"memo" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TokenTransportRequested>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenTransportRequested;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TokenTransportRequested",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            U256,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TokenTransportRequested with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TokenTransportRequested {
                            dst_chain_id: __field0,
                            token_id: __field1,
                            receiver: __field2,
                            amount: __field3,
                            channel_id: __field4,
                            memo: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<U256> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dst_chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "receiver",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "channel_id",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dst_chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("receiver")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("channel_id")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("memo")?
                            }
                        };
                        _serde::__private::Ok(TokenTransportRequested {
                            dst_chain_id: __field0,
                            token_id: __field1,
                            receiver: __field2,
                            amount: __field3,
                            channel_id: __field4,
                            memo: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "dst_chain_id",
                    "token_id",
                    "receiver",
                    "amount",
                    "channel_id",
                    "memo",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenTransportRequested",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TokenTransportRequested,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::ethers_core::abi::AbiType for TokenTransportRequested {
        fn param_type() -> ::ethers_core::abi::ParamType {
            ::ethers_core::abi::ParamType::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <U256 as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::AbiArrayType for TokenTransportRequested {}
    impl ::ethers_core::abi::Tokenizable for TokenTransportRequested
    where
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {
        fn from_token(
            token: ::ethers_core::abi::Token,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
            if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                if tokens.len() != 6usize {
                    return Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Expected 6 tokens, got {0}: {1:?}",
                                    tokens.len(),
                                    tokens,
                                ),
                            );
                            res
                        }),
                    );
                }
                let mut iter = tokens.into_iter();
                Ok(Self {
                    dst_chain_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    token_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    receiver: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    amount: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    channel_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    memo: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                })
            } else {
                Err(
                    ::ethers_core::abi::InvalidOutputType({
                        let res = ::alloc::fmt::format(
                            format_args!("Expected Tuple, got {0:?}", token),
                        );
                        res
                    }),
                )
            }
        }
        fn into_token(self) -> ::ethers_core::abi::Token {
            ::ethers_core::abi::Token::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        self.dst_chain_id.into_token(),
                        self.token_id.into_token(),
                        self.receiver.into_token(),
                        self.amount.into_token(),
                        self.channel_id.into_token(),
                        self.memo.into_token(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::TokenizableItem for TokenTransportRequested
    where
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {}
    impl ::ethers_contract::EthEvent for TokenTransportRequested {
        fn name() -> ::std::borrow::Cow<'static, str> {
            "TokenTransportRequested".into()
        }
        fn signature() -> ::ethers_core::types::H256 {
            ::ethers_core::types::H256([
                42,
                113,
                67,
                4,
                159,
                220,
                34,
                139,
                33,
                131,
                92,
                39,
                231,
                216,
                181,
                111,
                135,
                174,
                7,
                185,
                45,
                163,
                25,
                98,
                234,
                216,
                111,
                188,
                255,
                201,
                119,
                63,
            ])
        }
        fn abi_signature() -> ::std::borrow::Cow<'static, str> {
            "TokenTransportRequested(string,string,string,uint256,string,string)".into()
        }
        fn decode_log(
            log: &::ethers_core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
        where
            Self: Sized,
        {
            let ::ethers_core::abi::RawLog { data, topics } = log;
            let event_signature = topics
                .get(0)
                .ok_or(::ethers_core::abi::Error::InvalidData)?;
            if event_signature != &Self::signature() {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let topic_types = ::alloc::vec::Vec::new();
            let data_types = [
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::Uint(256usize),
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::String,
            ];
            let flat_topics = topics
                .iter()
                .skip(1)
                .flat_map(|t| t.as_ref().to_vec())
                .collect::<Vec<u8>>();
            let topic_tokens = ::ethers_core::abi::decode(&topic_types, &flat_topics)?;
            if topic_tokens.len() != topics.len() - 1 {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
            let tokens: Vec<_> = topic_tokens
                .into_iter()
                .chain(data_tokens.into_iter())
                .collect();
            ::ethers_core::abi::Tokenizable::from_token(
                    ::ethers_core::abi::Token::Tuple(tokens),
                )
                .map_err(|_| ::ethers_core::abi::Error::InvalidData)
        }
        fn is_anonymous() -> bool {
            false
        }
    }
    pub struct TokenBurned {
        pub token_id: String,
        pub receiver: String,
        pub amount: ethereum_types::U256,
        pub channel_id: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenBurned {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TokenBurned",
                "token_id",
                &self.token_id,
                "receiver",
                &self.receiver,
                "amount",
                &self.amount,
                "channel_id",
                &&self.channel_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenBurned {
        #[inline]
        fn clone(&self) -> TokenBurned {
            TokenBurned {
                token_id: ::core::clone::Clone::clone(&self.token_id),
                receiver: ::core::clone::Clone::clone(&self.receiver),
                amount: ::core::clone::Clone::clone(&self.amount),
                channel_id: ::core::clone::Clone::clone(&self.channel_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenBurned {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenBurned",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "receiver",
                    &self.receiver,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "channel_id",
                    &self.channel_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenBurned {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "receiver" => _serde::__private::Ok(__Field::__field1),
                            "amount" => _serde::__private::Ok(__Field::__field2),
                            "channel_id" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"receiver" => _serde::__private::Ok(__Field::__field1),
                            b"amount" => _serde::__private::Ok(__Field::__field2),
                            b"channel_id" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TokenBurned>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenBurned;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TokenBurned",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TokenBurned with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenBurned with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ethereum_types::U256,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TokenBurned with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TokenBurned with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TokenBurned {
                            token_id: __field0,
                            receiver: __field1,
                            amount: __field2,
                            channel_id: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ethereum_types::U256,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "receiver",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ethereum_types::U256,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "channel_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("receiver")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("channel_id")?
                            }
                        };
                        _serde::__private::Ok(TokenBurned {
                            token_id: __field0,
                            receiver: __field1,
                            amount: __field2,
                            channel_id: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "receiver",
                    "amount",
                    "channel_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenBurned",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TokenBurned>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::ethers_core::abi::AbiType for TokenBurned {
        fn param_type() -> ::ethers_core::abi::ParamType {
            ::ethers_core::abi::ParamType::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                        <ethereum_types::U256 as ::ethers_core::abi::AbiType>::param_type(),
                        <String as ::ethers_core::abi::AbiType>::param_type(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::AbiArrayType for TokenBurned {}
    impl ::ethers_core::abi::Tokenizable for TokenBurned
    where
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        ethereum_types::U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {
        fn from_token(
            token: ::ethers_core::abi::Token,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
            if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                if tokens.len() != 4usize {
                    return Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Expected 4 tokens, got {0}: {1:?}",
                                    tokens.len(),
                                    tokens,
                                ),
                            );
                            res
                        }),
                    );
                }
                let mut iter = tokens.into_iter();
                Ok(Self {
                    token_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    receiver: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    amount: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                    channel_id: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                })
            } else {
                Err(
                    ::ethers_core::abi::InvalidOutputType({
                        let res = ::alloc::fmt::format(
                            format_args!("Expected Tuple, got {0:?}", token),
                        );
                        res
                    }),
                )
            }
        }
        fn into_token(self) -> ::ethers_core::abi::Token {
            ::ethers_core::abi::Token::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        self.token_id.into_token(),
                        self.receiver.into_token(),
                        self.amount.into_token(),
                        self.channel_id.into_token(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::TokenizableItem for TokenBurned
    where
        String: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
        ethereum_types::U256: ::ethers_core::abi::Tokenize,
        String: ::ethers_core::abi::Tokenize,
    {}
    impl ::ethers_contract::EthEvent for TokenBurned {
        fn name() -> ::std::borrow::Cow<'static, str> {
            "TokenBurned".into()
        }
        fn signature() -> ::ethers_core::types::H256 {
            ::ethers_core::types::H256([
                176,
                83,
                180,
                69,
                38,
                168,
                90,
                103,
                204,
                167,
                33,
                147,
                104,
                37,
                80,
                62,
                55,
                199,
                204,
                14,
                26,
                23,
                81,
                139,
                247,
                15,
                99,
                158,
                22,
                206,
                65,
                141,
            ])
        }
        fn abi_signature() -> ::std::borrow::Cow<'static, str> {
            "TokenBurned(string,string,uint256,string)".into()
        }
        fn decode_log(
            log: &::ethers_core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
        where
            Self: Sized,
        {
            let ::ethers_core::abi::RawLog { data, topics } = log;
            let event_signature = topics
                .get(0)
                .ok_or(::ethers_core::abi::Error::InvalidData)?;
            if event_signature != &Self::signature() {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let topic_types = ::alloc::vec::Vec::new();
            let data_types = [
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::String,
                ::ethers_core::abi::ParamType::Uint(256usize),
                ::ethers_core::abi::ParamType::String,
            ];
            let flat_topics = topics
                .iter()
                .skip(1)
                .flat_map(|t| t.as_ref().to_vec())
                .collect::<Vec<u8>>();
            let topic_tokens = ::ethers_core::abi::decode(&topic_types, &flat_topics)?;
            if topic_tokens.len() != topics.len() - 1 {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
            let tokens: Vec<_> = topic_tokens
                .into_iter()
                .chain(data_tokens.into_iter())
                .collect();
            ::ethers_core::abi::Tokenizable::from_token(
                    ::ethers_core::abi::Token::Tuple(tokens),
                )
                .map_err(|_| ::ethers_core::abi::Error::InvalidData)
        }
        fn is_anonymous() -> bool {
            false
        }
    }
    pub struct DirectiveExecuted {
        pub seq: U256,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DirectiveExecuted {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "DirectiveExecuted",
                "seq",
                &&self.seq,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DirectiveExecuted {
        #[inline]
        fn clone(&self) -> DirectiveExecuted {
            DirectiveExecuted {
                seq: ::core::clone::Clone::clone(&self.seq),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DirectiveExecuted {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DirectiveExecuted",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DirectiveExecuted {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "seq" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"seq" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DirectiveExecuted>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DirectiveExecuted;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DirectiveExecuted",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            U256,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DirectiveExecuted with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DirectiveExecuted { seq: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<U256> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("seq")?
                            }
                        };
                        _serde::__private::Ok(DirectiveExecuted { seq: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["seq"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DirectiveExecuted",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DirectiveExecuted>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::ethers_core::abi::AbiType for DirectiveExecuted {
        fn param_type() -> ::ethers_core::abi::ParamType {
            ::ethers_core::abi::ParamType::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        <U256 as ::ethers_core::abi::AbiType>::param_type(),
                    ]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::AbiArrayType for DirectiveExecuted {}
    impl ::ethers_core::abi::Tokenizable for DirectiveExecuted
    where
        U256: ::ethers_core::abi::Tokenize,
    {
        fn from_token(
            token: ::ethers_core::abi::Token,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::InvalidOutputType> {
            if let ::ethers_core::abi::Token::Tuple(tokens) = token {
                if tokens.len() != 1usize {
                    return Err(
                        ::ethers_core::abi::InvalidOutputType({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Expected 1 tokens, got {0}: {1:?}",
                                    tokens.len(),
                                    tokens,
                                ),
                            );
                            res
                        }),
                    );
                }
                let mut iter = tokens.into_iter();
                Ok(Self {
                    seq: ::ethers_core::abi::Tokenizable::from_token(
                        iter
                            .next()
                            .expect(
                                "The iter is guaranteed to be something due to the size check",
                            ),
                    )?,
                })
            } else {
                Err(
                    ::ethers_core::abi::InvalidOutputType({
                        let res = ::alloc::fmt::format(
                            format_args!("Expected Tuple, got {0:?}", token),
                        );
                        res
                    }),
                )
            }
        }
        fn into_token(self) -> ::ethers_core::abi::Token {
            ::ethers_core::abi::Token::Tuple(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([self.seq.into_token()]),
                ),
            )
        }
    }
    impl ::ethers_core::abi::TokenizableItem for DirectiveExecuted
    where
        U256: ::ethers_core::abi::Tokenize,
    {}
    impl ::ethers_contract::EthEvent for DirectiveExecuted {
        fn name() -> ::std::borrow::Cow<'static, str> {
            "DirectiveExecuted".into()
        }
        fn signature() -> ::ethers_core::types::H256 {
            ::ethers_core::types::H256([
                71,
                95,
                210,
                135,
                153,
                150,
                230,
                209,
                98,
                121,
                89,
                189,
                150,
                125,
                138,
                213,
                175,
                21,
                69,
                235,
                115,
                163,
                2,
                175,
                119,
                111,
                241,
                248,
                230,
                139,
                94,
                155,
            ])
        }
        fn abi_signature() -> ::std::borrow::Cow<'static, str> {
            "DirectiveExecuted(uint256)".into()
        }
        fn decode_log(
            log: &::ethers_core::abi::RawLog,
        ) -> ::core::result::Result<Self, ::ethers_core::abi::Error>
        where
            Self: Sized,
        {
            let ::ethers_core::abi::RawLog { data, topics } = log;
            let event_signature = topics
                .get(0)
                .ok_or(::ethers_core::abi::Error::InvalidData)?;
            if event_signature != &Self::signature() {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let topic_types = ::alloc::vec::Vec::new();
            let data_types = [::ethers_core::abi::ParamType::Uint(256usize)];
            let flat_topics = topics
                .iter()
                .skip(1)
                .flat_map(|t| t.as_ref().to_vec())
                .collect::<Vec<u8>>();
            let topic_tokens = ::ethers_core::abi::decode(&topic_types, &flat_topics)?;
            if topic_tokens.len() != topics.len() - 1 {
                return Err(::ethers_core::abi::Error::InvalidData);
            }
            let data_tokens = ::ethers_core::abi::decode(&data_types, data)?;
            let tokens: Vec<_> = topic_tokens
                .into_iter()
                .chain(data_tokens.into_iter())
                .collect();
            ::ethers_core::abi::Tokenizable::from_token(
                    ::ethers_core::abi::Token::Tuple(tokens),
                )
                .map_err(|_| ::ethers_core::abi::Error::InvalidData)
        }
        fn is_anonymous() -> bool {
            false
        }
    }
    pub fn gen_execute_directive_data(directive: &Directive, seq: U256) -> Vec<u8> {
        let index: PortContractCommandIndex = directive.clone().into();
        let data = match directive {
            Directive::AddChain(c) => (index, seq, (c.chain_id.clone())).encode(),
            Directive::AddToken(t) => {
                let token = t.clone();
                let t_info = token.token_id_info();
                let settlement_chain_id = t_info[0].to_string();
                let token_id = token.token_id;
                let contract_addr = ethereum_types::Address::from([0u8; 20]);
                let name = token.name;
                let symbol = token.symbol;
                let decimal = token.decimals;
                (
                    index,
                    seq,
                    (settlement_chain_id, token_id, contract_addr, name, symbol, decimal),
                )
                    .encode()
            }
            Directive::ToggleChainState(t) => (index, seq, (t.chain_id.clone())).encode(),
            Directive::UpdateFee(f) => ::alloc::vec::Vec::new(),
        };
        let call = PrivilegedExecuteDirectiveCall {
            directive_bytes: Bytes::from(data),
        };
        call.encode()
    }
    pub fn gen_mint_token_data(ticket: &Ticket) -> Vec<u8> {
        let receiver = ethereum_types::Address::from_slice(
            EvmAddress::from_str(ticket.receiver.as_str()).unwrap().0.as_slice(),
        );
        let amount: u128 = ticket.amount.parse().unwrap();
        let call = PrivilegedMintTokenCall {
            token_id: ticket.token.clone(),
            receiver,
            amount: U256::from(amount),
            ticket_id: U256::from_str_radix(ticket.ticket_id.as_str(), 16).unwrap(),
            memo: String::from_utf8(ticket.memo.clone().unwrap_or_default())
                .unwrap_or_default(),
        };
        call.encode()
    }
    impl Into<PortContractCommandIndex> for Directive {
        fn into(self) -> PortContractCommandIndex {
            match self {
                Directive::AddChain(_) => 0u8,
                Directive::AddToken(_) => 1u8,
                Directive::UpdateFee(_) => 2u8,
                Directive::ToggleChainState(t) => {
                    match t.action {
                        ToggleAction::Activate => 4,
                        ToggleAction::Deactivate => 3,
                    }
                }
            }
        }
    }
    pub fn gen_eip1559_tx(tx_data: Vec<u8>) -> Eip1559TransactionRequest {
        let chain_id = read_state(|s| s.evm_chain_id);
        let port_contract_addr = read_state(|s| s.omnity_port_contract.clone());
        let tx = Eip1559TransactionRequest {
            chain_id: Some(chain_id.into()),
            from: None,
            to: Some(NameOrAddress::Address(port_contract_addr.into())),
            gas: None,
            value: None,
            nonce: None,
            data: Some(Bytes::from(tx_data)),
            access_list: Default::default(),
            max_priority_fee_per_gas: None,
            max_fee_per_gas: None,
        };
        tx
    }
}
pub mod eth_common {
    use std::str::FromStr;
    use candid::CandidType;
    use cketh_common::eth_rpc_client::RpcConfig;
    use ethereum_types::Address;
    use ethers_core::abi::{ethereum_types, AbiEncode};
    use ethers_core::types::{Eip1559TransactionRequest, U256};
    use ethers_core::utils::keccak256;
    use evm_rpc::candid_types::SendRawTransactionStatus;
    use evm_rpc::RpcServices;
    use ic_cdk::api::management_canister::ecdsa::{
        sign_with_ecdsa, SignWithEcdsaArgument,
    };
    use serde_derive::{Deserialize, Serialize};
    use crate::Error;
    const EVM_ADDR_BYTES_LEN: usize = 20;
    pub struct EvmAddress(pub(crate) [u8; EVM_ADDR_BYTES_LEN]);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EvmAddress {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EvmAddress>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EvmAddress;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "tuple struct EvmAddress",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::__private::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: [u8; EVM_ADDR_BYTES_LEN] = <[u8; EVM_ADDR_BYTES_LEN] as _serde::Deserialize>::deserialize(
                            __e,
                        )?;
                        _serde::__private::Ok(EvmAddress(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            [u8; EVM_ADDR_BYTES_LEN],
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"tuple struct EvmAddress with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EvmAddress(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "EvmAddress",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EvmAddress>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ::candid::types::CandidType for EvmAddress {
        fn _ty() -> ::candid::types::Type {
            <[u8; EVM_ADDR_BYTES_LEN] as ::candid::types::CandidType>::ty()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<EvmAddress>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.0)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EvmAddress {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_newtype_struct(
                    __serializer,
                    "EvmAddress",
                    &self.0,
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EvmAddress {
        #[inline]
        fn default() -> EvmAddress {
            EvmAddress(::core::default::Default::default())
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EvmAddress {
        #[inline]
        fn clone(&self) -> EvmAddress {
            EvmAddress(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EvmAddress {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EvmAddress {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<[u8; EVM_ADDR_BYTES_LEN]>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EvmAddress {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EvmAddress {
        #[inline]
        fn eq(&self, other: &EvmAddress) -> bool {
            self.0 == other.0
        }
    }
    pub enum EvmAddressError {
        #[error("Bytes is longer than 29 bytes.")]
        LengthError,
        #[error("Bytes is longer than 29 bytes.")]
        FormatError,
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for EvmAddressError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for EvmAddressError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                EvmAddressError::LengthError {} => {
                    __formatter.write_str("Bytes is longer than 29 bytes.")
                }
                EvmAddressError::FormatError {} => {
                    __formatter.write_str("Bytes is longer than 29 bytes.")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EvmAddressError {
        #[inline]
        fn clone(&self) -> EvmAddressError {
            match self {
                EvmAddressError::LengthError => EvmAddressError::LengthError,
                EvmAddressError::FormatError => EvmAddressError::FormatError,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EvmAddressError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    EvmAddressError::LengthError => "LengthError",
                    EvmAddressError::FormatError => "FormatError",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EvmAddressError {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EvmAddressError {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EvmAddressError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EvmAddressError {
        #[inline]
        fn eq(&self, other: &EvmAddressError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EvmAddressError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EvmAddressError::LengthError => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "EvmAddressError",
                            0u32,
                            "LengthError",
                        )
                    }
                    EvmAddressError::FormatError => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "EvmAddressError",
                            1u32,
                            "FormatError",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EvmAddressError {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "LengthError" => _serde::__private::Ok(__Field::__field0),
                            "FormatError" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"LengthError" => _serde::__private::Ok(__Field::__field0),
                            b"FormatError" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EvmAddressError>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EvmAddressError;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum EvmAddressError",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(EvmAddressError::LengthError)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(EvmAddressError::FormatError)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "LengthError",
                    "FormatError",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "EvmAddressError",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EvmAddressError>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Into<Address> for EvmAddress {
        fn into(self) -> Address {
            Address::from(self.0)
        }
    }
    impl AsRef<[u8]> for EvmAddress {
        fn as_ref(&self) -> &[u8] {
            self.0.as_slice()
        }
    }
    impl FromStr for EvmAddress {
        type Err = EvmAddressError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            EvmAddress::from_text(s)
        }
    }
    impl TryFrom<Vec<u8>> for EvmAddress {
        type Error = String;
        fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
            if value.len() != EVM_ADDR_BYTES_LEN {
                return Result::Err("addr_length_error".to_string());
            }
            let mut c = [0u8; EVM_ADDR_BYTES_LEN];
            c.copy_from_slice(value.as_slice());
            Ok(EvmAddress(c))
        }
    }
    impl EvmAddress {
        pub fn from_text<S: AsRef<str>>(text: S) -> Result<Self, EvmAddressError> {
            let t = if text.as_ref().starts_with("0x") {
                text.as_ref().strip_prefix("0x").unwrap()
            } else {
                text.as_ref()
            };
            let r = hex::decode(t).map_err(|_e| EvmAddressError::FormatError)?;
            if r.len() != EVM_ADDR_BYTES_LEN {
                return Err(EvmAddressError::LengthError);
            }
            let mut v = [0u8; 20];
            v.copy_from_slice(r.as_slice());
            Ok(EvmAddress(v))
        }
    }
    pub async fn sign_transaction(
        tx: Eip1559TransactionRequest,
    ) -> anyhow::Result<Vec<u8>> {
        use ethers_core::types::Signature;
        const EIP1559_TX_ID: u8 = 2;
        let mut unsigned_tx_bytes = tx.rlp().to_vec();
        unsigned_tx_bytes.insert(0, EIP1559_TX_ID);
        let txhash = keccak256(&unsigned_tx_bytes);
        let arg = SignWithEcdsaArgument {
            message_hash: txhash.clone().to_vec(),
            derivation_path: crate::state::key_derivation_path(),
            key_id: crate::state::key_id(),
        };
        let (r,) = sign_with_ecdsa(arg)
            .await
            .map_err(|(_, e)| super::Error::ChainKeyError(e))?;
        let signature = Signature {
            v: y_parity(&txhash, &r.signature, crate::state::try_public_key()?.as_ref()),
            r: U256::from_big_endian(&r.signature[0..32]),
            s: U256::from_big_endian(&r.signature[32..64]),
        };
        let mut signed_tx_bytes = tx.rlp_signed(&signature).to_vec();
        signed_tx_bytes.insert(0, EIP1559_TX_ID);
        Ok(signed_tx_bytes)
    }
    pub async fn broadcast(tx: Vec<u8>) -> Result<String, super::Error> {
        let raw = hex::encode(tx);
        let (r,): (SendRawTransactionStatus,) = ic_cdk::call(
                crate::state::rpc_addr(),
                "eth_sendRawTransaction",
                (
                    RpcServices::Custom {
                        chain_id: crate::state::target_chain_id(),
                        services: crate::state::rpc_providers(),
                    },
                    None::<RpcConfig>,
                    raw,
                ),
            )
            .await
            .map_err(|(_, e)| super::Error::EvmRpcError(e))?;
        match r {
            SendRawTransactionStatus::Ok(hash) => {
                hash.map(|h| h.to_string())
                    .ok_or(
                        super::Error::EvmRpcError(
                            "A transaction hash is expected".to_string(),
                        ),
                    )
            }
            _ => {
                Err(
                    super::Error::EvmRpcError({
                        let res = ::alloc::fmt::format(format_args!("{0:?}", r));
                        res
                    }),
                )
            }
        }
    }
    fn y_parity(prehash: &[u8], sig: &[u8], pubkey: &[u8]) -> u64 {
        use k256::ecdsa::{RecoveryId, Signature, VerifyingKey};
        let orig_key = VerifyingKey::from_sec1_bytes(pubkey)
            .expect("failed to parse the pubkey");
        let signature = Signature::try_from(sig).unwrap();
        for parity in [0u8, 1] {
            let recid = RecoveryId::try_from(parity).unwrap();
            let recovered_key = VerifyingKey::recover_from_prehash(
                    prehash,
                    &signature,
                    recid,
                )
                .expect("failed to recover key");
            if recovered_key == orig_key {
                return parity as u64;
            }
        }
        {
            ::core::panicking::panic_fmt(
                format_args!(
                    "failed to recover the parity bit from a signature; sig: {0}, pubkey: {1}",
                    hex::encode(sig),
                    hex::encode(pubkey),
                ),
            );
        }
    }
}
pub mod guard {
    use crate::state::mutate_state;
    #[must_use]
    pub struct TimerLogicGuard(());
    impl TimerLogicGuard {
        pub fn new() -> Option<Self> {
            mutate_state(|s| {
                if s.is_timer_running {
                    return None;
                }
                s.is_timer_running = true;
                Some(TimerLogicGuard(()))
            })
        }
    }
    impl Drop for TimerLogicGuard {
        fn drop(&mut self) {
            mutate_state(|s| {
                s.is_timer_running = false;
            });
        }
    }
}
pub mod hub {
    use crate::call_error::{CallError, Reason};
    use crate::types::Directive;
    use crate::types::Topic;
    use crate::types::{ChainId, Seq, Ticket};
    use candid::Principal;
    pub async fn send_ticket(
        hub_principal: Principal,
        ticket: Ticket,
    ) -> Result<(), CallError> {
        let cost_cycles = 4_000_000_000_u64;
        let resp: (Result<(), crate::types::Error>,) = ic_cdk::api::call::call_with_payment(
                hub_principal,
                "send_ticket",
                (ticket,),
                cost_cycles,
            )
            .await
            .map_err(|(code, message)| CallError {
                method: "send_ticket".to_string(),
                reason: Reason::from_reject(code, message),
            })?;
        let data = resp
            .0
            .map_err(|err| CallError {
                method: "send_ticket".to_string(),
                reason: Reason::CanisterError(err.to_string()),
            })?;
        Ok(data)
    }
    pub async fn query_tickets(
        hub_principal: Principal,
        offset: u64,
        limit: u64,
    ) -> Result<Vec<(Seq, Ticket)>, CallError> {
        let resp: (Result<Vec<(Seq, Ticket)>, crate::types::Error>,) = ic_cdk::api::call::call(
                hub_principal,
                "query_tickets",
                (None::<Option<ChainId>>, offset, limit),
            )
            .await
            .map_err(|(code, message)| CallError {
                method: "query_tickets".to_string(),
                reason: Reason::from_reject(code, message),
            })?;
        let data = resp
            .0
            .map_err(|err| CallError {
                method: "query_tickets".to_string(),
                reason: Reason::CanisterError(err.to_string()),
            })?;
        Ok(data)
    }
    pub async fn query_directives(
        hub_principal: Principal,
        offset: u64,
        limit: u64,
    ) -> Result<Vec<(Seq, Directive)>, CallError> {
        let resp: (Result<Vec<(Seq, Directive)>, crate::types::Error>,) = ic_cdk::api::call::call(
                hub_principal,
                "query_directives",
                (None::<Option<ChainId>>, None::<Option<Topic>>, offset, limit),
            )
            .await
            .map_err(|(code, message)| CallError {
                method: "query_directives".to_string(),
                reason: Reason::from_reject(code, message),
            })?;
        let data = resp
            .0
            .map_err(|err| CallError {
                method: "query_directives".to_string(),
                reason: Reason::CanisterError(err.to_string()),
            })?;
        Ok(data)
    }
}
pub mod hub_to_route {
    use crate::eth_common::EvmAddress;
    use crate::state::{mutate_state, read_state};
    use crate::types::{ChainState, Directive};
    use crate::{audit, hub};
    use log::self;
    use std::str::FromStr;
    pub const PERIODIC_TASK_INTERVAL: u64 = 5;
    pub const BATCH_QUERY_LIMIT: u64 = 20;
    pub const ICP_TRANSFER_FEE: u64 = 10_000;
    async fn process_tickets() {
        if read_state(|s| s.chain_state == ChainState::Deactive) {
            return;
        }
        let (hub_principal, offset) = read_state(|s| (
            s.hub_principal,
            s.next_ticket_seq,
        ));
        match hub::query_tickets(hub_principal, offset, BATCH_QUERY_LIMIT).await {
            Ok(tickets) => {
                let mut next_seq = offset;
                for (seq, ticket) in &tickets {
                    let _receiver = if let Ok(receiver) = EvmAddress::from_str(
                        &ticket.receiver,
                    ) {
                        receiver
                    } else {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "[process tickets] failed to parse ticket receiver: {0}",
                                        ticket.receiver,
                                    ),
                                    lvl,
                                    &(
                                        "cdk_route::hub_to_route",
                                        "cdk_route::hub_to_route",
                                        "src/hub_to_route.rs",
                                    ),
                                    26u32,
                                    (),
                                );
                            }
                        };
                        next_seq = seq + 1;
                        continue;
                    };
                    let _amount: u128 = if let Ok(amount) = ticket.amount.parse() {
                        amount
                    } else {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "[process tickets] failed to parse ticket amount: {0}",
                                        ticket.amount,
                                    ),
                                    lvl,
                                    &(
                                        "cdk_route::hub_to_route",
                                        "cdk_route::hub_to_route",
                                        "src/hub_to_route.rs",
                                    ),
                                    36u32,
                                    (),
                                );
                            }
                        };
                        next_seq = seq + 1;
                        continue;
                    };
                    mutate_state(|s| s.tickets_queue.insert(*seq, ticket.clone()));
                    next_seq = seq + 1;
                }
                mutate_state(|s| s.next_ticket_seq = next_seq)
            }
            Err(err) => {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[process tickets] failed to query tickets, err: {0}",
                                err,
                            ),
                            lvl,
                            &(
                                "cdk_route::hub_to_route",
                                "cdk_route::hub_to_route",
                                "src/hub_to_route.rs",
                            ),
                            49u32,
                            (),
                        );
                    }
                };
            }
        }
    }
    async fn process_directives() {
        let (hub_principal, offset) = read_state(|s| (
            s.hub_principal,
            s.next_directive_seq,
        ));
        match hub::query_directives(hub_principal, offset, BATCH_QUERY_LIMIT).await {
            Ok(directives) => {
                for (seq, directive) in &directives {
                    match directive.clone() {
                        Directive::AddChain(chain) => {
                            mutate_state(|s| audit::add_chain(s, chain.clone()));
                        }
                        Directive::AddToken(token) => {
                            match crate::updates::add_new_token(token.clone()).await {
                                Ok(_) => {
                                    {
                                        let lvl = ::log::Level::Info;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                format_args!(
                                                    "[process directives] add token successful, token id: {0}",
                                                    token.token_id,
                                                ),
                                                lvl,
                                                &(
                                                    "cdk_route::hub_to_route",
                                                    "cdk_route::hub_to_route",
                                                    "src/hub_to_route.rs",
                                                ),
                                                66u32,
                                                (),
                                            );
                                        }
                                    };
                                }
                                Err(err) => {
                                    {
                                        let lvl = ::log::Level::Error;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api::log(
                                                format_args!(
                                                    "[process directives] failed to add token: token id: {0}, err: {1:?}",
                                                    token.token_id,
                                                    err,
                                                ),
                                                lvl,
                                                &(
                                                    "cdk_route::hub_to_route",
                                                    "cdk_route::hub_to_route",
                                                    "src/hub_to_route.rs",
                                                ),
                                                72u32,
                                                (),
                                            );
                                        }
                                    };
                                    continue;
                                }
                            }
                        }
                        Directive::ToggleChainState(toggle) => {
                            mutate_state(|s| audit::toggle_chain_state(
                                s,
                                toggle.clone(),
                            ));
                        }
                        Directive::UpdateFee(fee) => {
                            mutate_state(|s| audit::update_fee(s, fee.clone()));
                            {
                                let lvl = ::log::Level::Info;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        format_args!(
                                            "[process_directives] success to update fee, fee: {0}",
                                            fee,
                                        ),
                                        lvl,
                                        &(
                                            "cdk_route::hub_to_route",
                                            "cdk_route::hub_to_route",
                                            "src/hub_to_route.rs",
                                        ),
                                        86u32,
                                        (),
                                    );
                                }
                            };
                        }
                    }
                    mutate_state(|s| s.directives_queue.insert(*seq, directive.clone()));
                }
                let next_seq = directives.last().map_or(offset, |(seq, _)| seq + 1);
                mutate_state(|s| {
                    s.next_directive_seq = next_seq;
                });
            }
            Err(err) => {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "[process directives] failed to query directives, err: {0:?}",
                                err,
                            ),
                            lvl,
                            &(
                                "cdk_route::hub_to_route",
                                "cdk_route::hub_to_route",
                                "src/hub_to_route.rs",
                            ),
                            97u32,
                            (),
                        );
                    }
                };
            }
        };
    }
    pub fn fetch_hub_periodic_task() {
        ic_cdk::spawn(async {
            let _guard = match crate::guard::TimerLogicGuard::new() {
                Some(guard) => guard,
                None => return,
            };
            process_directives().await;
            process_tickets().await;
        });
    }
}
pub mod route_to_cdk {
    use ethers_core::types::U256;
    use crate::contracts::{
        gen_eip1559_tx, gen_execute_directive_data, gen_mint_token_data,
    };
    use crate::eth_common::{broadcast, sign_transaction};
    use crate::state::{mutate_state, read_state};
    use crate::types::{PendingDirectiveStatus, PendingTicketStatus};
    pub fn to_cdk_task() {
        ic_cdk::spawn(async {
            let _guard = match crate::guard::TimerLogicGuard::new() {
                Some(guard) => guard,
                None => return,
            };
            send_directives_to_cdk().await;
            send_tickets_to_cdk().await;
        });
    }
    pub async fn send_directives_to_cdk() {
        let from = read_state(|s| s.next_consume_directive_seq);
        let to = read_state(|s| s.next_directive_seq);
        for seq in from..to {
            let dire = read_state(|s| s.directives_queue.get(&seq));
            match dire {
                None => {
                    continue;
                }
                Some(d) => {
                    let data = gen_execute_directive_data(&d, U256::from(seq));
                    let tx = gen_eip1559_tx(data);
                    let raw = sign_transaction(tx).await;
                    let mut pending_directive = PendingDirectiveStatus {
                        evm_tx_hash: None,
                        seq,
                        error: None,
                    };
                    match raw {
                        Ok(data) => {
                            let hash = broadcast(data).await;
                            match hash {
                                Ok(h) => {
                                    pending_directive.evm_tx_hash = Some(h);
                                }
                                Err(e) => {
                                    pending_directive.error = Some(e.to_string());
                                }
                            }
                        }
                        Err(e) => {
                            pending_directive.error = Some(e.to_string());
                        }
                    }
                    mutate_state(|s| {
                        s.pending_directive_map.insert(seq, pending_directive)
                    });
                }
            }
        }
        mutate_state(|s| s.next_consume_directive_seq = to);
    }
    pub async fn send_tickets_to_cdk() {
        let from = read_state(|s| s.next_consume_ticket_seq);
        let to = read_state(|s| s.next_ticket_seq);
        for seq in from..to {
            let ticket = read_state(|s| s.tickets_queue.get(&seq));
            match ticket {
                None => {
                    continue;
                }
                Some(t) => {
                    let data = gen_mint_token_data(&t);
                    let tx = gen_eip1559_tx(data);
                    let raw = sign_transaction(tx).await;
                    let mut pending_ticket = PendingTicketStatus {
                        evm_tx_hash: None,
                        ticket_id: t.ticket_id.clone(),
                        seq,
                        error: None,
                    };
                    match raw {
                        Ok(data) => {
                            let hash = broadcast(data).await;
                            match hash {
                                Ok(h) => {
                                    pending_ticket.evm_tx_hash = Some(h);
                                }
                                Err(e) => {
                                    pending_ticket.error = Some(e.to_string());
                                }
                            }
                        }
                        Err(e) => {
                            pending_ticket.error = Some(e.to_string());
                        }
                    }
                    mutate_state(|s| {
                        s.pending_tickets_map.insert(t.ticket_id, pending_ticket)
                    });
                }
            }
        }
        mutate_state(|s| s.next_consume_ticket_seq = to);
    }
}
pub mod service {
    use crate::Error;
    use ic_cdk::api::management_canister::ecdsa::{
        ecdsa_public_key, EcdsaPublicKeyArgument,
    };
    use ic_cdk::{init, post_upgrade, pre_upgrade, query, update};
    use crate::state::{
        key_derivation_path, key_id, mutate_state, read_state, CdkRouteState,
    };
    #[export_name = "canister_init"]
    fn __canister_method_init() {
        ic_cdk::setup();
        ic_cdk::spawn(async {
            let result = init();
        });
    }
    fn init() {
        mutate_state(|s| *s = CdkRouteState::default());
    }
    #[export_name = "canister_pre_upgrade"]
    fn __canister_method_pre_upgrade() {
        ic_cdk::setup();
        ic_cdk::spawn(async {
            let result = pre_upgrade();
        });
    }
    fn pre_upgrade() {
        read_state(|s| s.pre_upgrade());
    }
    #[export_name = "canister_post_upgrade"]
    fn __canister_method_post_upgrade() {
        ic_cdk::setup();
        ic_cdk::spawn(async {
            let result = post_upgrade();
        });
    }
    fn post_upgrade() {
        CdkRouteState::post_upgrade();
    }
    #[export_name = "canister_update init_chain_pubkey"]
    fn __canister_method_init_chain_pubkey() {
        ic_cdk::setup();
        let r: Result<(), String> = is_admin();
        if let Err(e) = r {
            ic_cdk::api::call::reject(&e);
            return;
        }
        ic_cdk::spawn(async {
            let () = ic_cdk::api::call::arg_data();
            let result = init_chain_pubkey().await;
            ic_cdk::api::call::reply((result,))
        });
    }
    async fn init_chain_pubkey() -> String {
        let arg = EcdsaPublicKeyArgument {
            canister_id: None,
            derivation_path: key_derivation_path(),
            key_id: key_id(),
        };
        let res = ecdsa_public_key(arg).await.map_err(|(_, e)| Error::ChainKeyError(e));
        match res {
            Ok((t,)) => {
                mutate_state(|s| s.pubkey = t.public_key.clone());
                hex::encode(t.public_key)
            }
            Err(e) => e.to_string(),
        }
    }
    #[export_name = "canister_query pubkey"]
    fn __canister_method_pubkey() {
        ic_cdk::setup();
        ic_cdk::spawn(async {
            let () = ic_cdk::api::call::arg_data();
            let result = pubkey();
            ic_cdk::api::call::reply((result,))
        });
    }
    fn pubkey() -> String {
        let key = read_state(|s| s.pubkey.clone());
        hex::encode(key)
    }
    fn is_admin() -> Result<(), String> {
        let c = ic_cdk::caller();
        match read_state(|s| s.admin == c) {
            true => Ok(()),
            false => Err("permission deny".to_string()),
        }
    }
    fn __export_service() -> String {
        use ::candid::types::{CandidType, Function, Type, TypeInner};
        let mut service = Vec::<(String, Type)>::new();
        let mut env = ::candid::types::internal::TypeContainer::new();
        {
            let mut args = Vec::new();
            let mut rets = Vec::new();
            rets.push(env.add::<String>());
            let func = Function {
                args,
                rets,
                modes: ::alloc::vec::Vec::new(),
            };
            service
                .push(("init_chain_pubkey".to_string(), TypeInner::Func(func).into()));
        }
        {
            let mut args = Vec::new();
            let mut rets = Vec::new();
            rets.push(env.add::<String>());
            let func = Function {
                args,
                rets,
                modes: <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([::candid::types::FuncMode::Query]),
                ),
            };
            service.push(("pubkey".to_string(), TypeInner::Func(func).into()));
        }
        service.sort_unstable_by_key(|(name, _)| name.clone());
        let ty = TypeInner::Service(service).into();
        let mut init_args = Vec::new();
        let actor = Some(TypeInner::Class(init_args, ty).into());
        let result = ::candid::bindings::candid::compile(&env.env, &actor);
        {
            let res = ::alloc::fmt::format(format_args!("{0}", result));
            res
        }
    }
    #[no_mangle]
    pub fn get_candid_pointer() -> *mut std::os::raw::c_char {
        let c_string = std::ffi::CString::new(__export_service()).unwrap();
        c_string.into_raw()
    }
}
pub mod stable_memory {
    use crate::types::{
        Directive, PendingDirectiveStatus, PendingTicketStatus, Seq, Ticket, TicketId,
    };
    use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
    use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
    use std::cell::RefCell;
    pub type InnerMemory = DefaultMemoryImpl;
    pub type Memory = VirtualMemory<InnerMemory>;
    pub const UPGRADE_STASH_MEMORY_ID: MemoryId = MemoryId::new(0);
    pub const TO_CDK_TICKETS_MEMORY_ID: MemoryId = MemoryId::new(1);
    pub const TO_CDK_DIRECTIVES_MEMORY_ID: MemoryId = MemoryId::new(2);
    pub const PENDING_TICKET_MAP_MEMORY_ID: MemoryId = MemoryId::new(3);
    pub const PENDING_DIRECTIVE_MAP_MEMORY_ID: MemoryId = MemoryId::new(4);
    const MEMORY: ::std::thread::LocalKey<RefCell<Option<InnerMemory>>> = {
        #[inline]
        fn __init() -> RefCell<Option<InnerMemory>> {
            RefCell::new(Some(InnerMemory::default()))
        }
        #[inline]
        unsafe fn __getit(
            init: ::std::option::Option<
                &mut ::std::option::Option<RefCell<Option<InnerMemory>>>,
            >,
        ) -> ::std::option::Option<&'static RefCell<Option<InnerMemory>>> {
            #[thread_local]
            static __KEY: ::std::thread::local_impl::Key<RefCell<Option<InnerMemory>>> = ::std::thread::local_impl::Key::<
                RefCell<Option<InnerMemory>>,
            >::new();
            unsafe {
                __KEY
                    .get(move || {
                        if let ::std::option::Option::Some(init) = init {
                            if let ::std::option::Option::Some(value) = init.take() {
                                return value;
                            } else if true {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "internal error: entered unreachable code: {0}",
                                            format_args!("missing default value"),
                                        ),
                                    );
                                };
                            }
                        }
                        __init()
                    })
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    const MEMORY_MANAGER: ::std::thread::LocalKey<
        RefCell<Option<MemoryManager<InnerMemory>>>,
    > = {
        #[inline]
        fn __init() -> RefCell<Option<MemoryManager<InnerMemory>>> {
            RefCell::new(
                Some(MemoryManager::init(MEMORY.with(|m| m.borrow().clone().unwrap()))),
            )
        }
        #[inline]
        unsafe fn __getit(
            init: ::std::option::Option<
                &mut ::std::option::Option<RefCell<Option<MemoryManager<InnerMemory>>>>,
            >,
        ) -> ::std::option::Option<
            &'static RefCell<Option<MemoryManager<InnerMemory>>>,
        > {
            #[thread_local]
            static __KEY: ::std::thread::local_impl::Key<
                RefCell<Option<MemoryManager<InnerMemory>>>,
            > = ::std::thread::local_impl::Key::<
                RefCell<Option<MemoryManager<InnerMemory>>>,
            >::new();
            unsafe {
                __KEY
                    .get(move || {
                        if let ::std::option::Option::Some(init) = init {
                            if let ::std::option::Option::Some(value) = init.take() {
                                return value;
                            } else if true {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "internal error: entered unreachable code: {0}",
                                            format_args!("missing default value"),
                                        ),
                                    );
                                };
                            }
                        }
                        __init()
                    })
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    fn with_memory_manager<R>(f: impl FnOnce(&MemoryManager<InnerMemory>) -> R) -> R {
        MEMORY_MANAGER
            .with(|cell| {
                f(cell.borrow().as_ref().expect("memory manager not initialized"))
            })
    }
    pub fn get_to_cdk_tickets_memory() -> Memory {
        with_memory_manager(|m| m.get(TO_CDK_TICKETS_MEMORY_ID))
    }
    pub fn get_to_cdk_directives_memory() -> Memory {
        with_memory_manager(|m| m.get(TO_CDK_DIRECTIVES_MEMORY_ID))
    }
    pub fn get_pending_ticket_map_memory() -> Memory {
        with_memory_manager(|m| m.get(PENDING_TICKET_MAP_MEMORY_ID))
    }
    pub fn get_pending_directive_map_memory() -> Memory {
        with_memory_manager(|m| m.get(PENDING_DIRECTIVE_MAP_MEMORY_ID))
    }
    pub fn get_upgrade_stash_memory() -> Memory {
        with_memory_manager(|m| m.get(UPGRADE_STASH_MEMORY_ID))
    }
    pub fn init_to_cdk_tickets_queue() -> StableBTreeMap<u64, Ticket, Memory> {
        StableBTreeMap::init(get_to_cdk_tickets_memory())
    }
    pub fn init_pending_ticket_map() -> StableBTreeMap<
        TicketId,
        PendingTicketStatus,
        Memory,
    > {
        StableBTreeMap::init(get_pending_ticket_map_memory())
    }
    pub fn init_pending_directive_map() -> StableBTreeMap<
        Seq,
        PendingDirectiveStatus,
        Memory,
    > {
        StableBTreeMap::init(get_pending_directive_map_memory())
    }
    pub fn init_to_cdk_directives_queue() -> StableBTreeMap<u64, Directive, Memory> {
        StableBTreeMap::init(get_to_cdk_directives_memory())
    }
}
pub mod state {
    use crate::eth_common::EvmAddress;
    use crate::stable_memory;
    use crate::stable_memory::Memory;
    use crate::types::{Chain, ChainState, Network, Token, TokenId};
    use crate::types::{
        ChainId, Directive, PendingDirectiveStatus, PendingTicketStatus, Seq, Ticket,
        TicketId,
    };
    use candid::{CandidType, Principal};
    use cketh_common::eth_rpc_client::providers::RpcApi;
    use ic_cdk::api::management_canister::ecdsa::EcdsaKeyId;
    use ic_stable_structures::writer::Writer;
    use ic_stable_structures::StableBTreeMap;
    use serde::{Deserialize, Serialize};
    use std::cell::RefCell;
    use std::collections::{BTreeMap, BTreeSet};
    const STATE: ::std::thread::LocalKey<RefCell<Option<CdkRouteState>>> = {
        #[inline]
        fn __init() -> RefCell<Option<CdkRouteState>> {
            RefCell::new(None)
        }
        #[inline]
        unsafe fn __getit(
            init: ::std::option::Option<
                &mut ::std::option::Option<RefCell<Option<CdkRouteState>>>,
            >,
        ) -> ::std::option::Option<&'static RefCell<Option<CdkRouteState>>> {
            #[thread_local]
            static __KEY: ::std::thread::local_impl::Key<
                RefCell<Option<CdkRouteState>>,
            > = ::std::thread::local_impl::Key::<RefCell<Option<CdkRouteState>>>::new();
            unsafe {
                __KEY
                    .get(move || {
                        if let ::std::option::Option::Some(init) = init {
                            if let ::std::option::Option::Some(value) = init.take() {
                                return value;
                            } else if true {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "internal error: entered unreachable code: {0}",
                                            format_args!("missing default value"),
                                        ),
                                    );
                                };
                            }
                        }
                        __init()
                    })
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    pub struct InitArgs {
        pub admin: Principal,
        pub chain_id: String,
        pub hub_principal: Principal,
        pub evm_chain_id: u64,
        pub evm_rpc_canister_addr: Principal,
        pub omnity_port_contract: Vec<u8>,
        pub scan_start_height: u64,
        pub network: Network,
    }
    impl ::candid::types::CandidType for InitArgs {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "evm_chain_id".to_string(),
                                    )
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("admin".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "omnity_port_contract".to_string(),
                                    )
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "hub_principal".to_string(),
                                    )
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("network".to_string())
                                    .into(),
                                ty: <Network as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "evm_rpc_canister_addr".to_string(),
                                    )
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "scan_start_height".to_string(),
                                    )
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<InitArgs>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.evm_chain_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.admin)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.omnity_port_contract,
            )?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.hub_principal)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.network)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.evm_rpc_canister_addr,
            )?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.scan_start_height,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InitArgs {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "admin" => _serde::__private::Ok(__Field::__field0),
                            "chain_id" => _serde::__private::Ok(__Field::__field1),
                            "hub_principal" => _serde::__private::Ok(__Field::__field2),
                            "evm_chain_id" => _serde::__private::Ok(__Field::__field3),
                            "evm_rpc_canister_addr" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "omnity_port_contract" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "scan_start_height" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "network" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"admin" => _serde::__private::Ok(__Field::__field0),
                            b"chain_id" => _serde::__private::Ok(__Field::__field1),
                            b"hub_principal" => _serde::__private::Ok(__Field::__field2),
                            b"evm_chain_id" => _serde::__private::Ok(__Field::__field3),
                            b"evm_rpc_canister_addr" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"omnity_port_contract" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"scan_start_height" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"network" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InitArgs>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InitArgs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InitArgs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Network,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct InitArgs with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(InitArgs {
                            admin: __field0,
                            chain_id: __field1,
                            hub_principal: __field2,
                            evm_chain_id: __field3,
                            evm_rpc_canister_addr: __field4,
                            omnity_port_contract: __field5,
                            scan_start_height: __field6,
                            network: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Network> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("admin"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hub_principal",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_chain_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_rpc_canister_addr",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "omnity_port_contract",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_start_height",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "network",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Network>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("admin")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("hub_principal")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_chain_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "evm_rpc_canister_addr",
                                )?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "omnity_port_contract",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_start_height")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("network")?
                            }
                        };
                        _serde::__private::Ok(InitArgs {
                            admin: __field0,
                            chain_id: __field1,
                            hub_principal: __field2,
                            evm_chain_id: __field3,
                            evm_rpc_canister_addr: __field4,
                            omnity_port_contract: __field5,
                            scan_start_height: __field6,
                            network: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "admin",
                    "chain_id",
                    "hub_principal",
                    "evm_chain_id",
                    "evm_rpc_canister_addr",
                    "omnity_port_contract",
                    "scan_start_height",
                    "network",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InitArgs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InitArgs>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl CdkRouteState {
        pub fn default() -> Self {
            CdkRouteState {
                admin: Principal::anonymous(),
                hub_principal: Principal::anonymous(),
                omnity_chain_id: "cdk".to_string(),
                evm_chain_id: 4800,
                tokens: Default::default(),
                counterparties: Default::default(),
                finalized_mint_token_requests: Default::default(),
                chain_state: ChainState::Active,
                evm_rpc_addr: Principal::anonymous(),
                key_id: Network::Local.key_id(),
                key_derivation_path: <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([b"m/44'/223'/0'/0/0".to_vec()]),
                ),
                nonce: 0,
                pubkey: ::alloc::vec::Vec::new(),
                rpc_privders: ::alloc::vec::Vec::new(),
                omnity_port_contract: EvmAddress::try_from([0u8; 32].to_vec())
                    .expect("omnity port contract address error"),
                next_ticket_seq: 0,
                next_directive_seq: 0,
                next_consume_ticket_seq: 0,
                next_consume_directive_seq: 0,
                handled_cdk_event: Default::default(),
                tickets_queue: StableBTreeMap::init(
                    crate::stable_memory::get_to_cdk_tickets_memory(),
                ),
                directives_queue: StableBTreeMap::init(
                    crate::stable_memory::get_to_cdk_directives_memory(),
                ),
                pending_tickets_map: StableBTreeMap::init(
                    crate::stable_memory::get_pending_ticket_map_memory(),
                ),
                pending_directive_map: StableBTreeMap::init(
                    crate::stable_memory::get_pending_directive_map_memory(),
                ),
                scan_start_height: 1000,
                is_timer_running: false,
            }
        }
        pub fn init(args: InitArgs) -> anyhow::Result<Self> {
            let ret = CdkRouteState {
                admin: args.admin,
                hub_principal: args.hub_principal,
                omnity_chain_id: args.chain_id,
                evm_chain_id: args.evm_chain_id,
                tokens: Default::default(),
                counterparties: Default::default(),
                finalized_mint_token_requests: Default::default(),
                chain_state: ChainState::Active,
                evm_rpc_addr: args.evm_rpc_canister_addr,
                key_id: args.network.key_id(),
                key_derivation_path: <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([b"m/44'/223'/0'/0/0".to_vec()]),
                ),
                nonce: 0,
                pubkey: ::alloc::vec::Vec::new(),
                rpc_privders: ::alloc::vec::Vec::new(),
                omnity_port_contract: EvmAddress::try_from(args.omnity_port_contract)
                    .expect("omnity port contract address error"),
                next_ticket_seq: 0,
                next_directive_seq: 0,
                next_consume_ticket_seq: 0,
                next_consume_directive_seq: 0,
                handled_cdk_event: Default::default(),
                tickets_queue: StableBTreeMap::init(
                    crate::stable_memory::get_to_cdk_tickets_memory(),
                ),
                directives_queue: StableBTreeMap::init(
                    crate::stable_memory::get_to_cdk_directives_memory(),
                ),
                pending_tickets_map: StableBTreeMap::init(
                    crate::stable_memory::get_pending_ticket_map_memory(),
                ),
                pending_directive_map: StableBTreeMap::init(
                    crate::stable_memory::get_pending_directive_map_memory(),
                ),
                scan_start_height: args.scan_start_height,
                is_timer_running: false,
            };
            Ok(ret)
        }
        pub fn pre_upgrade(&self) {
            let mut state_bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut state_bytes);
            let len = state_bytes.len() as u32;
            let mut memory = crate::stable_memory::get_upgrade_stash_memory();
            let mut writer = Writer::new(&mut memory, 0);
            writer.write(&len.to_le_bytes()).expect("failed to save hub state len");
            writer.write(&state_bytes).expect("failed to save hub state");
        }
        pub fn post_upgrade() {
            use ic_stable_structures::Memory;
            let memory = stable_memory::get_upgrade_stash_memory();
            let mut state_len_bytes = [0; 4];
            memory.read(0, &mut state_len_bytes);
            let state_len = u32::from_le_bytes(state_len_bytes) as usize;
            let mut state_bytes = ::alloc::vec::from_elem(0, state_len);
            memory.read(4, &mut state_bytes);
            let state: CdkRouteState = ciborium::de::from_reader(&*state_bytes)
                .expect("failed to decode state");
            STATE.with(|s| *s.borrow_mut() = Some(state));
        }
    }
    pub struct CdkRouteState {
        pub admin: Principal,
        pub hub_principal: Principal,
        pub omnity_chain_id: String,
        pub evm_chain_id: u64,
        pub tokens: BTreeMap<TokenId, Token>,
        pub counterparties: BTreeMap<ChainId, Chain>,
        pub finalized_mint_token_requests: BTreeMap<TicketId, u64>,
        pub chain_state: ChainState,
        pub evm_rpc_addr: Principal,
        pub key_id: EcdsaKeyId,
        pub key_derivation_path: Vec<Vec<u8>>,
        pub nonce: u64,
        pub pubkey: Vec<u8>,
        pub rpc_privders: Vec<RpcApi>,
        pub omnity_port_contract: EvmAddress,
        pub next_ticket_seq: u64,
        pub next_directive_seq: u64,
        pub next_consume_ticket_seq: u64,
        pub next_consume_directive_seq: u64,
        pub handled_cdk_event: BTreeSet<String>,
        #[serde(skip, default = "crate::stable_memory::init_to_cdk_tickets_queue")]
        pub tickets_queue: StableBTreeMap<u64, Ticket, Memory>,
        #[serde(skip, default = "crate::stable_memory::init_to_cdk_directives_queue")]
        pub directives_queue: StableBTreeMap<u64, Directive, Memory>,
        #[serde(skip, default = "crate::stable_memory::init_pending_ticket_map")]
        pub pending_tickets_map: StableBTreeMap<TicketId, PendingTicketStatus, Memory>,
        #[serde(skip, default = "crate::stable_memory::init_pending_directive_map")]
        pub pending_directive_map: StableBTreeMap<Seq, PendingDirectiveStatus, Memory>,
        pub scan_start_height: u64,
        #[serde(skip)]
        pub is_timer_running: bool,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CdkRouteState {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field24,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field24),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "admin" => _serde::__private::Ok(__Field::__field0),
                            "hub_principal" => _serde::__private::Ok(__Field::__field1),
                            "omnity_chain_id" => _serde::__private::Ok(__Field::__field2),
                            "evm_chain_id" => _serde::__private::Ok(__Field::__field3),
                            "tokens" => _serde::__private::Ok(__Field::__field4),
                            "counterparties" => _serde::__private::Ok(__Field::__field5),
                            "finalized_mint_token_requests" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "chain_state" => _serde::__private::Ok(__Field::__field7),
                            "evm_rpc_addr" => _serde::__private::Ok(__Field::__field8),
                            "key_id" => _serde::__private::Ok(__Field::__field9),
                            "key_derivation_path" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "nonce" => _serde::__private::Ok(__Field::__field11),
                            "pubkey" => _serde::__private::Ok(__Field::__field12),
                            "rpc_privders" => _serde::__private::Ok(__Field::__field13),
                            "omnity_port_contract" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            "next_ticket_seq" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "next_directive_seq" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            "next_consume_ticket_seq" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            "next_consume_directive_seq" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            "handled_cdk_event" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            "scan_start_height" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"admin" => _serde::__private::Ok(__Field::__field0),
                            b"hub_principal" => _serde::__private::Ok(__Field::__field1),
                            b"omnity_chain_id" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"evm_chain_id" => _serde::__private::Ok(__Field::__field3),
                            b"tokens" => _serde::__private::Ok(__Field::__field4),
                            b"counterparties" => _serde::__private::Ok(__Field::__field5),
                            b"finalized_mint_token_requests" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"chain_state" => _serde::__private::Ok(__Field::__field7),
                            b"evm_rpc_addr" => _serde::__private::Ok(__Field::__field8),
                            b"key_id" => _serde::__private::Ok(__Field::__field9),
                            b"key_derivation_path" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"nonce" => _serde::__private::Ok(__Field::__field11),
                            b"pubkey" => _serde::__private::Ok(__Field::__field12),
                            b"rpc_privders" => _serde::__private::Ok(__Field::__field13),
                            b"omnity_port_contract" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"next_ticket_seq" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"next_directive_seq" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            b"next_consume_ticket_seq" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            b"next_consume_directive_seq" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            b"handled_cdk_event" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            b"scan_start_height" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CdkRouteState>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CdkRouteState;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CdkRouteState",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            BTreeMap<TokenId, Token>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            BTreeMap<ChainId, Chain>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            BTreeMap<TicketId, u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            ChainState,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            EcdsaKeyId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Vec<Vec<u8>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Vec<RpcApi>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            EvmAddress,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field17 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        17usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field18 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        18usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field19 = match _serde::de::SeqAccess::next_element::<
                            BTreeSet<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        19usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field20 = crate::stable_memory::init_to_cdk_tickets_queue();
                        let __field21 = crate::stable_memory::init_to_cdk_directives_queue();
                        let __field22 = crate::stable_memory::init_pending_ticket_map();
                        let __field23 = crate::stable_memory::init_pending_directive_map();
                        let __field24 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        20usize,
                                        &"struct CdkRouteState with 21 elements",
                                    ),
                                );
                            }
                        };
                        let __field25 = _serde::__private::Default::default();
                        _serde::__private::Ok(CdkRouteState {
                            admin: __field0,
                            hub_principal: __field1,
                            omnity_chain_id: __field2,
                            evm_chain_id: __field3,
                            tokens: __field4,
                            counterparties: __field5,
                            finalized_mint_token_requests: __field6,
                            chain_state: __field7,
                            evm_rpc_addr: __field8,
                            key_id: __field9,
                            key_derivation_path: __field10,
                            nonce: __field11,
                            pubkey: __field12,
                            rpc_privders: __field13,
                            omnity_port_contract: __field14,
                            next_ticket_seq: __field15,
                            next_directive_seq: __field16,
                            next_consume_ticket_seq: __field17,
                            next_consume_directive_seq: __field18,
                            handled_cdk_event: __field19,
                            tickets_queue: __field20,
                            directives_queue: __field21,
                            pending_tickets_map: __field22,
                            pending_directive_map: __field23,
                            scan_start_height: __field24,
                            is_timer_running: __field25,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            BTreeMap<TokenId, Token>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            BTreeMap<ChainId, Chain>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<
                            BTreeMap<TicketId, u64>,
                        > = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<ChainState> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<EcdsaKeyId> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Vec<Vec<u8>>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<Vec<RpcApi>> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<EvmAddress> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<BTreeSet<String>> = _serde::__private::None;
                        let mut __field24: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("admin"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hub_principal",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "omnity_chain_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_chain_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tokens"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeMap<TokenId, Token>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "counterparties",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeMap<ChainId, Chain>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "finalized_mint_token_requests",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeMap<TicketId, u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_state",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainState>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_rpc_addr",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("key_id"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<EcdsaKeyId>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "key_derivation_path",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Vec<u8>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "rpc_privders",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<RpcApi>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "omnity_port_contract",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<EvmAddress>(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "next_ticket_seq",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "next_directive_seq",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "next_consume_ticket_seq",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "next_consume_directive_seq",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "handled_cdk_event",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeSet<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field24 => {
                                    if _serde::__private::Option::is_some(&__field24) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_start_height",
                                            ),
                                        );
                                    }
                                    __field24 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("admin")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("hub_principal")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("omnity_chain_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_chain_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tokens")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("counterparties")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "finalized_mint_token_requests",
                                )?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_state")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_rpc_addr")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("key_id")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("key_derivation_path")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nonce")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pubkey")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("rpc_privders")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "omnity_port_contract",
                                )?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("next_ticket_seq")?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("next_directive_seq")?
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "next_consume_ticket_seq",
                                )?
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "next_consume_directive_seq",
                                )?
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("handled_cdk_event")?
                            }
                        };
                        let __field24 = match __field24 {
                            _serde::__private::Some(__field24) => __field24,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_start_height")?
                            }
                        };
                        _serde::__private::Ok(CdkRouteState {
                            admin: __field0,
                            hub_principal: __field1,
                            omnity_chain_id: __field2,
                            evm_chain_id: __field3,
                            tokens: __field4,
                            counterparties: __field5,
                            finalized_mint_token_requests: __field6,
                            chain_state: __field7,
                            evm_rpc_addr: __field8,
                            key_id: __field9,
                            key_derivation_path: __field10,
                            nonce: __field11,
                            pubkey: __field12,
                            rpc_privders: __field13,
                            omnity_port_contract: __field14,
                            next_ticket_seq: __field15,
                            next_directive_seq: __field16,
                            next_consume_ticket_seq: __field17,
                            next_consume_directive_seq: __field18,
                            handled_cdk_event: __field19,
                            tickets_queue: crate::stable_memory::init_to_cdk_tickets_queue(),
                            directives_queue: crate::stable_memory::init_to_cdk_directives_queue(),
                            pending_tickets_map: crate::stable_memory::init_pending_ticket_map(),
                            pending_directive_map: crate::stable_memory::init_pending_directive_map(),
                            scan_start_height: __field24,
                            is_timer_running: _serde::__private::Default::default(),
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "admin",
                    "hub_principal",
                    "omnity_chain_id",
                    "evm_chain_id",
                    "tokens",
                    "counterparties",
                    "finalized_mint_token_requests",
                    "chain_state",
                    "evm_rpc_addr",
                    "key_id",
                    "key_derivation_path",
                    "nonce",
                    "pubkey",
                    "rpc_privders",
                    "omnity_port_contract",
                    "next_ticket_seq",
                    "next_directive_seq",
                    "next_consume_ticket_seq",
                    "next_consume_directive_seq",
                    "handled_cdk_event",
                    "scan_start_height",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CdkRouteState",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CdkRouteState>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CdkRouteState {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CdkRouteState",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "admin",
                    &self.admin,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hub_principal",
                    &self.hub_principal,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "omnity_chain_id",
                    &self.omnity_chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_chain_id",
                    &self.evm_chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tokens",
                    &self.tokens,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "counterparties",
                    &self.counterparties,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "finalized_mint_token_requests",
                    &self.finalized_mint_token_requests,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_state",
                    &self.chain_state,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_rpc_addr",
                    &self.evm_rpc_addr,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key_id",
                    &self.key_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key_derivation_path",
                    &self.key_derivation_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nonce",
                    &self.nonce,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pubkey",
                    &self.pubkey,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rpc_privders",
                    &self.rpc_privders,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "omnity_port_contract",
                    &self.omnity_port_contract,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "next_ticket_seq",
                    &self.next_ticket_seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "next_directive_seq",
                    &self.next_directive_seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "next_consume_ticket_seq",
                    &self.next_consume_ticket_seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "next_consume_directive_seq",
                    &self.next_consume_directive_seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "handled_cdk_event",
                    &self.handled_cdk_event,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_start_height",
                    &self.scan_start_height,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    pub fn is_active() -> bool {
        read_state(|s| s.chain_state == ChainState::Active)
    }
    pub fn hub_addr() -> Principal {
        read_state(|s| s.hub_principal.clone())
    }
    pub fn rpc_addr() -> Principal {
        read_state(|s| s.evm_rpc_addr.clone())
    }
    pub fn rpc_providers() -> Vec<RpcApi> {
        read_state(|s| s.rpc_privders.clone())
    }
    pub fn target_chain_id() -> u64 {
        read_state(|s| s.evm_chain_id)
    }
    pub fn try_public_key() -> crate::Result<Vec<u8>> {
        Ok(read_state(|s| s.pubkey.clone()))
    }
    pub fn key_id() -> EcdsaKeyId {
        read_state(|s| s.key_id.clone())
    }
    pub fn key_derivation_path() -> Vec<Vec<u8>> {
        read_state(|s| s.key_derivation_path.clone())
    }
    pub fn mutate_state<F, R>(f: F) -> R
    where
        F: FnOnce(&mut CdkRouteState) -> R,
    {
        STATE.with(|s| f(s.borrow_mut().as_mut().expect("State not initialized!")))
    }
    pub fn read_state<F, R>(f: F) -> R
    where
        F: FnOnce(&CdkRouteState) -> R,
    {
        STATE.with(|s| f(s.borrow().as_ref().expect("State not initialized!")))
    }
    /// Replaces the current state.
    pub fn replace_state(state: CdkRouteState) {
        STATE
            .with(|s| {
                *s.borrow_mut() = Some(state);
            });
    }
    pub fn take_state<F, R>(f: F) -> R
    where
        F: FnOnce(CdkRouteState) -> R,
    {
        STATE.with(|s| f(s.take().expect("State not initialized!")))
    }
}
pub mod types {
    use std::{
        collections::{BTreeMap, HashMap},
        str::FromStr,
    };
    use candid::CandidType;
    use ic_stable_structures::storable::Bound;
    use ic_stable_structures::Storable;
    use serde::{Deserialize, Serialize};
    use sha2::Digest;
    use std::borrow::Cow;
    use thiserror::Error;
    pub type Signature = Vec<u8>;
    pub type Seq = u64;
    pub type Timestamp = u64;
    pub type ChainId = String;
    pub type DstChain = ChainId;
    pub type TokenId = String;
    pub type TicketId = String;
    pub type Account = String;
    pub struct PendingTicketStatus {
        pub evm_tx_hash: Option<String>,
        pub ticket_id: TicketId,
        pub seq: u64,
        pub error: Option<String>,
    }
    impl ::candid::types::CandidType for PendingTicketStatus {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("seq".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("evm_tx_hash".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("ticket_id".to_string())
                                    .into(),
                                ty: <TicketId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("error".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<PendingTicketStatus>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.seq)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.evm_tx_hash)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.ticket_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.error)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PendingTicketStatus {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "evm_tx_hash" => _serde::__private::Ok(__Field::__field0),
                            "ticket_id" => _serde::__private::Ok(__Field::__field1),
                            "seq" => _serde::__private::Ok(__Field::__field2),
                            "error" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"evm_tx_hash" => _serde::__private::Ok(__Field::__field0),
                            b"ticket_id" => _serde::__private::Ok(__Field::__field1),
                            b"seq" => _serde::__private::Ok(__Field::__field2),
                            b"error" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PendingTicketStatus>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PendingTicketStatus;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PendingTicketStatus",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PendingTicketStatus with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TicketId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PendingTicketStatus with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PendingTicketStatus with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PendingTicketStatus with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PendingTicketStatus {
                            evm_tx_hash: __field0,
                            ticket_id: __field1,
                            seq: __field2,
                            error: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TicketId> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_tx_hash",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ticket_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TicketId>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_tx_hash")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ticket_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("seq")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("error")?
                            }
                        };
                        _serde::__private::Ok(PendingTicketStatus {
                            evm_tx_hash: __field0,
                            ticket_id: __field1,
                            seq: __field2,
                            error: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "evm_tx_hash",
                    "ticket_id",
                    "seq",
                    "error",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PendingTicketStatus",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PendingTicketStatus>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PendingTicketStatus {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PendingTicketStatus",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_tx_hash",
                    &self.evm_tx_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ticket_id",
                    &self.ticket_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "error",
                    &self.error,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PendingTicketStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PendingTicketStatus {
        #[inline]
        fn eq(&self, other: &PendingTicketStatus) -> bool {
            self.evm_tx_hash == other.evm_tx_hash && self.ticket_id == other.ticket_id
                && self.seq == other.seq && self.error == other.error
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PendingTicketStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PendingTicketStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<TicketId>;
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PendingTicketStatus {
        #[inline]
        fn clone(&self) -> PendingTicketStatus {
            PendingTicketStatus {
                evm_tx_hash: ::core::clone::Clone::clone(&self.evm_tx_hash),
                ticket_id: ::core::clone::Clone::clone(&self.ticket_id),
                seq: ::core::clone::Clone::clone(&self.seq),
                error: ::core::clone::Clone::clone(&self.error),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PendingTicketStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PendingTicketStatus",
                "evm_tx_hash",
                &self.evm_tx_hash,
                "ticket_id",
                &self.ticket_id,
                "seq",
                &self.seq,
                "error",
                &&self.error,
            )
        }
    }
    pub struct PendingDirectiveStatus {
        pub evm_tx_hash: Option<String>,
        pub seq: u64,
        pub error: Option<String>,
    }
    impl ::candid::types::CandidType for PendingDirectiveStatus {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("seq".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("evm_tx_hash".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("error".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<PendingDirectiveStatus>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.seq)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.evm_tx_hash)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.error)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PendingDirectiveStatus {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "evm_tx_hash" => _serde::__private::Ok(__Field::__field0),
                            "seq" => _serde::__private::Ok(__Field::__field1),
                            "error" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"evm_tx_hash" => _serde::__private::Ok(__Field::__field0),
                            b"seq" => _serde::__private::Ok(__Field::__field1),
                            b"error" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PendingDirectiveStatus>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PendingDirectiveStatus;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PendingDirectiveStatus",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PendingDirectiveStatus with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PendingDirectiveStatus with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PendingDirectiveStatus with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PendingDirectiveStatus {
                            evm_tx_hash: __field0,
                            seq: __field1,
                            error: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_tx_hash",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_tx_hash")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("seq")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("error")?
                            }
                        };
                        _serde::__private::Ok(PendingDirectiveStatus {
                            evm_tx_hash: __field0,
                            seq: __field1,
                            error: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["evm_tx_hash", "seq", "error"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PendingDirectiveStatus",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PendingDirectiveStatus>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PendingDirectiveStatus {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PendingDirectiveStatus",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_tx_hash",
                    &self.evm_tx_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "error",
                    &self.error,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PendingDirectiveStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PendingDirectiveStatus {
        #[inline]
        fn eq(&self, other: &PendingDirectiveStatus) -> bool {
            self.evm_tx_hash == other.evm_tx_hash && self.seq == other.seq
                && self.error == other.error
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PendingDirectiveStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PendingDirectiveStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PendingDirectiveStatus {
        #[inline]
        fn clone(&self) -> PendingDirectiveStatus {
            PendingDirectiveStatus {
                evm_tx_hash: ::core::clone::Clone::clone(&self.evm_tx_hash),
                seq: ::core::clone::Clone::clone(&self.seq),
                error: ::core::clone::Clone::clone(&self.error),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PendingDirectiveStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PendingDirectiveStatus",
                "evm_tx_hash",
                &self.evm_tx_hash,
                "seq",
                &self.seq,
                "error",
                &&self.error,
            )
        }
    }
    impl Storable for PendingDirectiveStatus {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let pds = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode pending ticket status");
            pds
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl Storable for PendingTicketStatus {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let pts = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode pending ticket status");
            pts
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub enum Directive {
        AddChain(Chain),
        AddToken(Token),
        ToggleChainState(ToggleState),
        UpdateFee(Factor),
    }
    impl ::candid::types::CandidType for Directive {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("UpdateFee".to_owned())
                                    .into(),
                                ty: <Factor as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("AddToken".to_owned())
                                    .into(),
                                ty: <Token as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("AddChain".to_owned())
                                    .into(),
                                ty: <Chain as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ToggleChainState".to_owned(),
                                    )
                                    .into(),
                                ty: <ToggleState as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Directive>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Directive::UpdateFee(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Directive::AddToken(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Directive::AddChain(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Directive::ToggleChainState(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(3u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Directive {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "AddChain" => _serde::__private::Ok(__Field::__field0),
                            "AddToken" => _serde::__private::Ok(__Field::__field1),
                            "ToggleChainState" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "UpdateFee" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"AddChain" => _serde::__private::Ok(__Field::__field0),
                            b"AddToken" => _serde::__private::Ok(__Field::__field1),
                            b"ToggleChainState" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"UpdateFee" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Directive>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Directive;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Directive",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Chain,
                                    >(__variant),
                                    Directive::AddChain,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Token,
                                    >(__variant),
                                    Directive::AddToken,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ToggleState,
                                    >(__variant),
                                    Directive::ToggleChainState,
                                )
                            }
                            (__Field::__field3, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Factor,
                                    >(__variant),
                                    Directive::UpdateFee,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "AddChain",
                    "AddToken",
                    "ToggleChainState",
                    "UpdateFee",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Directive",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Directive>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Directive {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Directive::AddChain(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Directive",
                            0u32,
                            "AddChain",
                            __field0,
                        )
                    }
                    Directive::AddToken(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Directive",
                            1u32,
                            "AddToken",
                            __field0,
                        )
                    }
                    Directive::ToggleChainState(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Directive",
                            2u32,
                            "ToggleChainState",
                            __field0,
                        )
                    }
                    Directive::UpdateFee(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Directive",
                            3u32,
                            "UpdateFee",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Directive {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Directive {
        #[inline]
        fn eq(&self, other: &Directive) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Directive::AddChain(__self_0), Directive::AddChain(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Directive::AddToken(__self_0), Directive::AddToken(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Directive::ToggleChainState(__self_0),
                        Directive::ToggleChainState(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Directive::UpdateFee(__self_0), Directive::UpdateFee(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Directive {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Directive {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Chain>;
            let _: ::core::cmp::AssertParamIsEq<Token>;
            let _: ::core::cmp::AssertParamIsEq<ToggleState>;
            let _: ::core::cmp::AssertParamIsEq<Factor>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Directive {
        #[inline]
        fn clone(&self) -> Directive {
            match self {
                Directive::AddChain(__self_0) => {
                    Directive::AddChain(::core::clone::Clone::clone(__self_0))
                }
                Directive::AddToken(__self_0) => {
                    Directive::AddToken(::core::clone::Clone::clone(__self_0))
                }
                Directive::ToggleChainState(__self_0) => {
                    Directive::ToggleChainState(::core::clone::Clone::clone(__self_0))
                }
                Directive::UpdateFee(__self_0) => {
                    Directive::UpdateFee(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Directive {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Directive::AddChain(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddChain",
                        &__self_0,
                    )
                }
                Directive::AddToken(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddToken",
                        &__self_0,
                    )
                }
                Directive::ToggleChainState(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ToggleChainState",
                        &__self_0,
                    )
                }
                Directive::UpdateFee(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UpdateFee",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl Directive {
        pub fn to_topic(&self) -> Topic {
            match self {
                Self::AddChain(_) => Topic::AddChain,
                Self::AddToken(_) => Topic::AddToken,
                Self::ToggleChainState(_) => Topic::ToggleChainState,
                Self::UpdateFee(_) => Topic::UpdateFee,
            }
        }
    }
    impl Storable for Directive {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let dire = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            dire
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl core::fmt::Display for Directive {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            match self {
                Directive::AddChain(chain) => {
                    f.write_fmt(format_args!("AddChain({0})", chain))
                }
                Directive::AddToken(token) => {
                    f.write_fmt(format_args!("AddToken({0})", token))
                }
                Directive::ToggleChainState(toggle_state) => {
                    f.write_fmt(format_args!("ToggleChainState({0})", toggle_state))
                }
                Directive::UpdateFee(factor) => {
                    f.write_fmt(format_args!("UpdateFee({0})", factor))
                }
            }
        }
    }
    impl Directive {
        pub fn hash(&self) -> String {
            let mut hasher = sha2::Sha256::new();
            hasher.update(self.to_string().as_bytes());
            let bytes: [u8; 32] = hasher.finalize().into();
            bytes
                .iter()
                .map(|byte| {
                    let res = ::alloc::fmt::format(format_args!("{0:02x}", byte));
                    res
                })
                .collect()
        }
    }
    pub struct DireKey {
        pub chain_id: ChainId,
        pub seq: Seq,
    }
    impl ::candid::types::CandidType for DireKey {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("seq".to_string()).into(),
                                ty: <Seq as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<DireKey>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.seq)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DireKey {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_id" => _serde::__private::Ok(__Field::__field0),
                            "seq" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"seq" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DireKey>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DireKey;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DireKey",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DireKey with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Seq,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DireKey with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DireKey {
                            chain_id: __field0,
                            seq: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Seq> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Seq>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("seq")?
                            }
                        };
                        _serde::__private::Ok(DireKey {
                            chain_id: __field0,
                            seq: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["chain_id", "seq"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DireKey",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DireKey>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DireKey {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DireKey",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for DireKey {
        #[inline]
        fn clone(&self) -> DireKey {
            DireKey {
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                seq: ::core::clone::Clone::clone(&self.seq),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DireKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DireKey",
                "chain_id",
                &self.chain_id,
                "seq",
                &&self.seq,
            )
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DireKey {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DireKey,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.chain_id, &other.chain_id) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.seq, &other.seq)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DireKey {
        #[inline]
        fn cmp(&self, other: &DireKey) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.chain_id, &other.chain_id) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.seq, &other.seq)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DireKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DireKey {
        #[inline]
        fn eq(&self, other: &DireKey) -> bool {
            self.chain_id == other.chain_id && self.seq == other.seq
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DireKey {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DireKey {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<Seq>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DireKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.chain_id, state);
            ::core::hash::Hash::hash(&self.seq, state)
        }
    }
    impl Storable for DireKey {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let dk = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            dk
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub struct DireMap {
        pub dires: BTreeMap<Seq, Directive>,
    }
    impl ::candid::types::CandidType for DireMap {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("dires".to_string())
                                    .into(),
                                ty: <BTreeMap<
                                    Seq,
                                    Directive,
                                > as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<DireMap>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.dires)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DireMap {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "dires" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"dires" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DireMap>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DireMap;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DireMap",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            BTreeMap<Seq, Directive>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DireMap with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DireMap { dires: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            BTreeMap<Seq, Directive>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("dires"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeMap<Seq, Directive>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dires")?
                            }
                        };
                        _serde::__private::Ok(DireMap { dires: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["dires"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DireMap",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DireMap>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DireMap {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DireMap",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dires",
                    &self.dires,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for DireMap {
        #[inline]
        fn clone(&self) -> DireMap {
            DireMap {
                dires: ::core::clone::Clone::clone(&self.dires),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DireMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "DireMap",
                "dires",
                &&self.dires,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for DireMap {
        #[inline]
        fn default() -> DireMap {
            DireMap {
                dires: ::core::default::Default::default(),
            }
        }
    }
    impl DireMap {
        pub fn from(seq: Seq, dire: Directive) -> Self {
            Self {
                dires: BTreeMap::from([(seq, dire)]),
            }
        }
    }
    impl Storable for DireMap {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let dire = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            dire
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub enum Topic {
        AddChain,
        AddToken,
        ToggleChainState,
        UpdateFee,
    }
    impl ::candid::types::CandidType for Topic {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("UpdateFee".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("AddToken".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("AddChain".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ToggleChainState".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Topic>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Topic::UpdateFee => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                Topic::AddToken => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                Topic::AddChain => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                }
                Topic::ToggleChainState => {
                    let mut ser = __serializer.serialize_variant(3u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Topic {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "AddChain" => _serde::__private::Ok(__Field::__field0),
                            "AddToken" => _serde::__private::Ok(__Field::__field1),
                            "ToggleChainState" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "UpdateFee" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"AddChain" => _serde::__private::Ok(__Field::__field0),
                            b"AddToken" => _serde::__private::Ok(__Field::__field1),
                            b"ToggleChainState" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"UpdateFee" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Topic>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Topic;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Topic",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Topic::AddChain)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Topic::AddToken)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Topic::ToggleChainState)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Topic::UpdateFee)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "AddChain",
                    "AddToken",
                    "ToggleChainState",
                    "UpdateFee",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Topic",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Topic>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Topic {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Topic::AddChain => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Topic",
                            0u32,
                            "AddChain",
                        )
                    }
                    Topic::AddToken => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Topic",
                            1u32,
                            "AddToken",
                        )
                    }
                    Topic::ToggleChainState => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Topic",
                            2u32,
                            "ToggleChainState",
                        )
                    }
                    Topic::UpdateFee => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Topic",
                            3u32,
                            "UpdateFee",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Topic {
        #[inline]
        fn clone(&self) -> Topic {
            match self {
                Topic::AddChain => Topic::AddChain,
                Topic::AddToken => Topic::AddToken,
                Topic::ToggleChainState => Topic::ToggleChainState,
                Topic::UpdateFee => Topic::UpdateFee,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Topic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Topic::AddChain => "AddChain",
                    Topic::AddToken => "AddToken",
                    Topic::ToggleChainState => "ToggleChainState",
                    Topic::UpdateFee => "UpdateFee",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Topic {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Topic {
        #[inline]
        fn eq(&self, other: &Topic) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Topic {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Topic {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Topic {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Topic,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Topic {
        #[inline]
        fn cmp(&self, other: &Topic) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
        }
    }
    impl Storable for Topic {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let topic = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            topic
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub enum TicketType {
        #[default]
        Normal,
        Resubmit,
    }
    impl ::candid::types::CandidType for TicketType {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Resubmit".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Normal".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TicketType>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                TicketType::Resubmit => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                TicketType::Normal => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TicketType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Normal" => _serde::__private::Ok(__Field::__field0),
                            "Resubmit" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Normal" => _serde::__private::Ok(__Field::__field0),
                            b"Resubmit" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TicketType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TicketType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TicketType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TicketType::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TicketType::Resubmit)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Normal", "Resubmit"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TicketType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TicketType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TicketType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TicketType::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TicketType",
                            0u32,
                            "Normal",
                        )
                    }
                    TicketType::Resubmit => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TicketType",
                            1u32,
                            "Resubmit",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TicketType {
        #[inline]
        fn default() -> TicketType {
            Self::Normal
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TicketType {
        #[inline]
        fn clone(&self) -> TicketType {
            match self {
                TicketType::Normal => TicketType::Normal,
                TicketType::Resubmit => TicketType::Resubmit,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TicketType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TicketType::Normal => "Normal",
                    TicketType::Resubmit => "Resubmit",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TicketType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TicketType {
        #[inline]
        fn eq(&self, other: &TicketType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TicketType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TicketType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TicketType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TicketType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TicketType {
        #[inline]
        fn cmp(&self, other: &TicketType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TicketType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    pub struct Ticket {
        pub ticket_id: TicketId,
        pub ticket_type: TicketType,
        pub ticket_time: Timestamp,
        pub src_chain: ChainId,
        pub dst_chain: ChainId,
        pub action: TxAction,
        pub token: TokenId,
        pub amount: String,
        pub sender: Option<Account>,
        pub receiver: Account,
        pub memo: Option<Vec<u8>>,
    }
    impl ::candid::types::CandidType for Ticket {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token".to_string())
                                    .into(),
                                ty: <TokenId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("action".to_string())
                                    .into(),
                                ty: <TxAction as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("dst_chain".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("memo".to_string())
                                    .into(),
                                ty: <Option<Vec<u8>> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("ticket_id".to_string())
                                    .into(),
                                ty: <TicketId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("sender".to_string())
                                    .into(),
                                ty: <Option<Account> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("ticket_time".to_string())
                                    .into(),
                                ty: <Timestamp as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("ticket_type".to_string())
                                    .into(),
                                ty: <TicketType as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("src_chain".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("amount".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("receiver".to_string())
                                    .into(),
                                ty: <Account as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Ticket>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.action)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.dst_chain)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.memo)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.ticket_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.sender)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.ticket_time)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.ticket_type)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.src_chain)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.amount)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.receiver)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Ticket {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "ticket_id" => _serde::__private::Ok(__Field::__field0),
                            "ticket_type" => _serde::__private::Ok(__Field::__field1),
                            "ticket_time" => _serde::__private::Ok(__Field::__field2),
                            "src_chain" => _serde::__private::Ok(__Field::__field3),
                            "dst_chain" => _serde::__private::Ok(__Field::__field4),
                            "action" => _serde::__private::Ok(__Field::__field5),
                            "token" => _serde::__private::Ok(__Field::__field6),
                            "amount" => _serde::__private::Ok(__Field::__field7),
                            "sender" => _serde::__private::Ok(__Field::__field8),
                            "receiver" => _serde::__private::Ok(__Field::__field9),
                            "memo" => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"ticket_id" => _serde::__private::Ok(__Field::__field0),
                            b"ticket_type" => _serde::__private::Ok(__Field::__field1),
                            b"ticket_time" => _serde::__private::Ok(__Field::__field2),
                            b"src_chain" => _serde::__private::Ok(__Field::__field3),
                            b"dst_chain" => _serde::__private::Ok(__Field::__field4),
                            b"action" => _serde::__private::Ok(__Field::__field5),
                            b"token" => _serde::__private::Ok(__Field::__field6),
                            b"amount" => _serde::__private::Ok(__Field::__field7),
                            b"sender" => _serde::__private::Ok(__Field::__field8),
                            b"receiver" => _serde::__private::Ok(__Field::__field9),
                            b"memo" => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Ticket>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Ticket;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Ticket",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TicketId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TicketType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Timestamp,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            TxAction,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            TokenId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<Account>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Account,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Option<Vec<u8>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct Ticket with 11 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Ticket {
                            ticket_id: __field0,
                            ticket_type: __field1,
                            ticket_time: __field2,
                            src_chain: __field3,
                            dst_chain: __field4,
                            action: __field5,
                            token: __field6,
                            amount: __field7,
                            sender: __field8,
                            receiver: __field9,
                            memo: __field10,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<TicketId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TicketType> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Timestamp> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<TxAction> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<TokenId> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<Account>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Account> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Option<Vec<u8>>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ticket_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TicketId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ticket_type",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TicketType>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ticket_time",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Timestamp>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "src_chain",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dst_chain",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TxAction>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TokenId>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("sender"),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Account>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "receiver",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Account>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("memo"),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Vec<u8>>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ticket_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ticket_type")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ticket_time")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("src_chain")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dst_chain")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sender")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("receiver")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("memo")?
                            }
                        };
                        _serde::__private::Ok(Ticket {
                            ticket_id: __field0,
                            ticket_type: __field1,
                            ticket_time: __field2,
                            src_chain: __field3,
                            dst_chain: __field4,
                            action: __field5,
                            token: __field6,
                            amount: __field7,
                            sender: __field8,
                            receiver: __field9,
                            memo: __field10,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "ticket_id",
                    "ticket_type",
                    "ticket_time",
                    "src_chain",
                    "dst_chain",
                    "action",
                    "token",
                    "amount",
                    "sender",
                    "receiver",
                    "memo",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Ticket",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Ticket>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Ticket {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Ticket",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ticket_id",
                    &self.ticket_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ticket_type",
                    &self.ticket_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ticket_time",
                    &self.ticket_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "src_chain",
                    &self.src_chain,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dst_chain",
                    &self.dst_chain,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token",
                    &self.token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sender",
                    &self.sender,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "receiver",
                    &self.receiver,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "memo",
                    &self.memo,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Ticket {
        #[inline]
        fn default() -> Ticket {
            Ticket {
                ticket_id: ::core::default::Default::default(),
                ticket_type: ::core::default::Default::default(),
                ticket_time: ::core::default::Default::default(),
                src_chain: ::core::default::Default::default(),
                dst_chain: ::core::default::Default::default(),
                action: ::core::default::Default::default(),
                token: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
                sender: ::core::default::Default::default(),
                receiver: ::core::default::Default::default(),
                memo: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ticket {
        #[inline]
        fn clone(&self) -> Ticket {
            Ticket {
                ticket_id: ::core::clone::Clone::clone(&self.ticket_id),
                ticket_type: ::core::clone::Clone::clone(&self.ticket_type),
                ticket_time: ::core::clone::Clone::clone(&self.ticket_time),
                src_chain: ::core::clone::Clone::clone(&self.src_chain),
                dst_chain: ::core::clone::Clone::clone(&self.dst_chain),
                action: ::core::clone::Clone::clone(&self.action),
                token: ::core::clone::Clone::clone(&self.token),
                amount: ::core::clone::Clone::clone(&self.amount),
                sender: ::core::clone::Clone::clone(&self.sender),
                receiver: ::core::clone::Clone::clone(&self.receiver),
                memo: ::core::clone::Clone::clone(&self.memo),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ticket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "ticket_id",
                "ticket_type",
                "ticket_time",
                "src_chain",
                "dst_chain",
                "action",
                "token",
                "amount",
                "sender",
                "receiver",
                "memo",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.ticket_id,
                &self.ticket_type,
                &self.ticket_time,
                &self.src_chain,
                &self.dst_chain,
                &self.action,
                &self.token,
                &self.amount,
                &self.sender,
                &self.receiver,
                &&self.memo,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Ticket",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ticket {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ticket {
        #[inline]
        fn eq(&self, other: &Ticket) -> bool {
            self.ticket_id == other.ticket_id && self.ticket_type == other.ticket_type
                && self.ticket_time == other.ticket_time
                && self.src_chain == other.src_chain && self.dst_chain == other.dst_chain
                && self.action == other.action && self.token == other.token
                && self.amount == other.amount && self.sender == other.sender
                && self.receiver == other.receiver && self.memo == other.memo
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Ticket {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Ticket {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TicketId>;
            let _: ::core::cmp::AssertParamIsEq<TicketType>;
            let _: ::core::cmp::AssertParamIsEq<Timestamp>;
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<TxAction>;
            let _: ::core::cmp::AssertParamIsEq<TokenId>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Option<Account>>;
            let _: ::core::cmp::AssertParamIsEq<Account>;
            let _: ::core::cmp::AssertParamIsEq<Option<Vec<u8>>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Ticket {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Ticket,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.ticket_id,
                &other.ticket_id,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.ticket_type,
                        &other.ticket_type,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.ticket_time,
                                &other.ticket_time,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.src_chain,
                                        &other.src_chain,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.dst_chain,
                                                &other.dst_chain,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.action,
                                                        &other.action,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.token,
                                                                &other.token,
                                                            ) {
                                                                ::core::option::Option::Some(
                                                                    ::core::cmp::Ordering::Equal,
                                                                ) => {
                                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                                        &self.amount,
                                                                        &other.amount,
                                                                    ) {
                                                                        ::core::option::Option::Some(
                                                                            ::core::cmp::Ordering::Equal,
                                                                        ) => {
                                                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                                                &self.sender,
                                                                                &other.sender,
                                                                            ) {
                                                                                ::core::option::Option::Some(
                                                                                    ::core::cmp::Ordering::Equal,
                                                                                ) => {
                                                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                                                        &self.receiver,
                                                                                        &other.receiver,
                                                                                    ) {
                                                                                        ::core::option::Option::Some(
                                                                                            ::core::cmp::Ordering::Equal,
                                                                                        ) => {
                                                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                                                &self.memo,
                                                                                                &other.memo,
                                                                                            )
                                                                                        }
                                                                                        cmp => cmp,
                                                                                    }
                                                                                }
                                                                                cmp => cmp,
                                                                            }
                                                                        }
                                                                        cmp => cmp,
                                                                    }
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Ticket {
        #[inline]
        fn cmp(&self, other: &Ticket) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.ticket_id, &other.ticket_id) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.ticket_type, &other.ticket_type) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.ticket_time,
                                &other.ticket_time,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.src_chain,
                                        &other.src_chain,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.dst_chain,
                                                &other.dst_chain,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(&self.action, &other.action) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            match ::core::cmp::Ord::cmp(&self.token, &other.token) {
                                                                ::core::cmp::Ordering::Equal => {
                                                                    match ::core::cmp::Ord::cmp(&self.amount, &other.amount) {
                                                                        ::core::cmp::Ordering::Equal => {
                                                                            match ::core::cmp::Ord::cmp(&self.sender, &other.sender) {
                                                                                ::core::cmp::Ordering::Equal => {
                                                                                    match ::core::cmp::Ord::cmp(
                                                                                        &self.receiver,
                                                                                        &other.receiver,
                                                                                    ) {
                                                                                        ::core::cmp::Ordering::Equal => {
                                                                                            ::core::cmp::Ord::cmp(&self.memo, &other.memo)
                                                                                        }
                                                                                        cmp => cmp,
                                                                                    }
                                                                                }
                                                                                cmp => cmp,
                                                                            }
                                                                        }
                                                                        cmp => cmp,
                                                                    }
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Ticket {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.ticket_id, state);
            ::core::hash::Hash::hash(&self.ticket_type, state);
            ::core::hash::Hash::hash(&self.ticket_time, state);
            ::core::hash::Hash::hash(&self.src_chain, state);
            ::core::hash::Hash::hash(&self.dst_chain, state);
            ::core::hash::Hash::hash(&self.action, state);
            ::core::hash::Hash::hash(&self.token, state);
            ::core::hash::Hash::hash(&self.amount, state);
            ::core::hash::Hash::hash(&self.sender, state);
            ::core::hash::Hash::hash(&self.receiver, state);
            ::core::hash::Hash::hash(&self.memo, state)
        }
    }
    impl Ticket {
        pub fn from_burn_event(
            log_entry: &LogEntry,
            token_burned: TokenBurnedFilter,
        ) -> Self {
            let src_chain = read_state(|s| s.omnity_chain_id.clone());
            let token = read_state(|s| {
                s.tokens
                    .get(&token_burned.token_id.to_string())
                    .expect("token not found")
                    .clone()
            });
            let dst_chain = token.token_id_info()[0].to_string();
            let ticket = Ticket {
                ticket_id: log_entry.transaction_hash.clone().unwrap().to_string()
                    + log_entry.log_index.clone().unwrap().to_string().as_str(),
                ticket_time: log_entry.block_number.clone().unwrap().as_f64() as u64,
                ticket_type: TicketType::Normal,
                src_chain,
                dst_chain,
                action: TxAction::Redeem,
                token: token_burned.token_id,
                amount: token_burned.amount.to_string(),
                sender: None,
                receiver: token_burned.receiver,
                memo: None,
            };
            ticket
        }
        pub fn from_transport_event(
            log_entry: &LogEntry,
            token_transport_requested: TokenTransportRequestedFilter,
        ) -> Self {
            let src_chain = read_state(|s| s.omnity_chain_id.clone());
            let dst_chain = token_transport_requested.dst_chain_id;
            let ticket = Ticket {
                ticket_id: log_entry.transaction_hash.clone().unwrap().to_string()
                    + log_entry.log_index.clone().unwrap().to_string().as_str(),
                ticket_time: log_entry.block_number.clone().unwrap().as_f64() as u64,
                ticket_type: TicketType::Normal,
                src_chain,
                dst_chain,
                action: TxAction::Transfer,
                token: token_transport_requested.token_id.to_string(),
                amount: token_transport_requested.amount.to_string(),
                sender: None,
                receiver: token_transport_requested.receiver,
                memo: Some(token_transport_requested.memo.into_bytes()),
            };
            ticket
        }
    }
    impl Storable for Ticket {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let ticket = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            ticket
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl core::fmt::Display for Ticket {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\nticket id:{0} \nticket type:{1:?} \ncreated time:{2} \nsrc chain:{3} \ndst_chain:{4} \naction:{5:?} \ntoken:{6} \namount:{7} \nsender:{8:?} \nrecevier:{9} \nmemo:{10:?}",
                    self.ticket_id,
                    self.ticket_type,
                    self.ticket_time,
                    self.src_chain,
                    self.dst_chain,
                    self.action,
                    self.token,
                    self.amount,
                    self.sender,
                    self.receiver,
                    self.memo,
                ),
            )
        }
    }
    pub struct SeqKey {
        pub chain_id: ChainId,
        pub seq: Seq,
    }
    impl ::candid::types::CandidType for SeqKey {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("seq".to_string()).into(),
                                ty: <Seq as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<SeqKey>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.seq)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SeqKey {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_id" => _serde::__private::Ok(__Field::__field0),
                            "seq" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"seq" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SeqKey>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SeqKey;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct SeqKey",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SeqKey with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Seq,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct SeqKey with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(SeqKey {
                            chain_id: __field0,
                            seq: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Seq> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("seq"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Seq>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("seq")?
                            }
                        };
                        _serde::__private::Ok(SeqKey {
                            chain_id: __field0,
                            seq: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["chain_id", "seq"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SeqKey",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SeqKey>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SeqKey {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SeqKey",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "seq",
                    &self.seq,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SeqKey {
        #[inline]
        fn default() -> SeqKey {
            SeqKey {
                chain_id: ::core::default::Default::default(),
                seq: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SeqKey {
        #[inline]
        fn clone(&self) -> SeqKey {
            SeqKey {
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                seq: ::core::clone::Clone::clone(&self.seq),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SeqKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "SeqKey",
                "chain_id",
                &self.chain_id,
                "seq",
                &&self.seq,
            )
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SeqKey {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SeqKey,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.chain_id, &other.chain_id) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.seq, &other.seq)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SeqKey {
        #[inline]
        fn cmp(&self, other: &SeqKey) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.chain_id, &other.chain_id) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.seq, &other.seq)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SeqKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SeqKey {
        #[inline]
        fn eq(&self, other: &SeqKey) -> bool {
            self.chain_id == other.chain_id && self.seq == other.seq
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for SeqKey {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SeqKey {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<Seq>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SeqKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.chain_id, state);
            ::core::hash::Hash::hash(&self.seq, state)
        }
    }
    impl SeqKey {
        pub fn from(chain_id: ChainId, seq: Seq) -> Self {
            Self { chain_id, seq }
        }
    }
    impl Storable for SeqKey {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let tk = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            tk
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub struct TicketMap {
        pub tickets: BTreeMap<Seq, Ticket>,
    }
    impl ::candid::types::CandidType for TicketMap {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("tickets".to_string())
                                    .into(),
                                ty: <BTreeMap<
                                    Seq,
                                    Ticket,
                                > as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TicketMap>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.tickets)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TicketMap {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tickets" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tickets" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TicketMap>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TicketMap;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TicketMap",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            BTreeMap<Seq, Ticket>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TicketMap with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TicketMap { tickets: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            BTreeMap<Seq, Ticket>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tickets",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            BTreeMap<Seq, Ticket>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tickets")?
                            }
                        };
                        _serde::__private::Ok(TicketMap { tickets: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["tickets"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TicketMap",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TicketMap>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TicketMap {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TicketMap",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tickets",
                    &self.tickets,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TicketMap {
        #[inline]
        fn default() -> TicketMap {
            TicketMap {
                tickets: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TicketMap {
        #[inline]
        fn clone(&self) -> TicketMap {
            TicketMap {
                tickets: ::core::clone::Clone::clone(&self.tickets),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TicketMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "TicketMap",
                "tickets",
                &&self.tickets,
            )
        }
    }
    impl TicketMap {
        pub fn from(seq: Seq, ticket: Ticket) -> Self {
            Self {
                tickets: BTreeMap::from([(seq, ticket)]),
            }
        }
    }
    impl Storable for TicketMap {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let ticket = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            ticket
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    pub enum ChainType {
        #[default]
        SettlementChain,
        ExecutionChain,
    }
    impl ::candid::types::CandidType for ChainType {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "SettlementChain".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ExecutionChain".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ChainType>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ChainType::SettlementChain => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ChainType::ExecutionChain => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ChainType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "SettlementChain" => _serde::__private::Ok(__Field::__field0),
                            "ExecutionChain" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"SettlementChain" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"ExecutionChain" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ChainType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ChainType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ChainType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ChainType::SettlementChain)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ChainType::ExecutionChain)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "SettlementChain",
                    "ExecutionChain",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ChainType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ChainType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ChainType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ChainType::SettlementChain => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChainType",
                            0u32,
                            "SettlementChain",
                        )
                    }
                    ChainType::ExecutionChain => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChainType",
                            1u32,
                            "ExecutionChain",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ChainType {
        #[inline]
        fn default() -> ChainType {
            Self::SettlementChain
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChainType {
        #[inline]
        fn clone(&self) -> ChainType {
            match self {
                ChainType::SettlementChain => ChainType::SettlementChain,
                ChainType::ExecutionChain => ChainType::ExecutionChain,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ChainType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ChainType::SettlementChain => "SettlementChain",
                    ChainType::ExecutionChain => "ExecutionChain",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChainType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChainType {
        #[inline]
        fn eq(&self, other: &ChainType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ChainType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ChainType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ChainType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ChainType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ChainType {
        #[inline]
        fn cmp(&self, other: &ChainType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ChainType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    pub enum ChainState {
        #[default]
        Active,
        Deactive,
    }
    impl ::candid::types::CandidType for ChainState {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Active".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Deactive".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ChainState>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ChainState::Active => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ChainState::Deactive => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ChainState {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Active" => _serde::__private::Ok(__Field::__field0),
                            "Deactive" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Active" => _serde::__private::Ok(__Field::__field0),
                            b"Deactive" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ChainState>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ChainState;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ChainState",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ChainState::Active)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ChainState::Deactive)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Active", "Deactive"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ChainState",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ChainState>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ChainState {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ChainState::Active => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChainState",
                            0u32,
                            "Active",
                        )
                    }
                    ChainState::Deactive => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChainState",
                            1u32,
                            "Deactive",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ChainState {
        #[inline]
        fn default() -> ChainState {
            Self::Active
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChainState {
        #[inline]
        fn clone(&self) -> ChainState {
            match self {
                ChainState::Active => ChainState::Active,
                ChainState::Deactive => ChainState::Deactive,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ChainState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ChainState::Active => "Active",
                    ChainState::Deactive => "Deactive",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChainState {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChainState {
        #[inline]
        fn eq(&self, other: &ChainState) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ChainState {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ChainState {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ChainState {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    pub enum ToggleAction {
        #[default]
        Activate,
        Deactivate,
    }
    impl ::candid::types::CandidType for ToggleAction {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Deactivate".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Activate".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ToggleAction>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ToggleAction::Deactivate => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ToggleAction::Activate => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ToggleAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Activate" => _serde::__private::Ok(__Field::__field0),
                            "Deactivate" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Activate" => _serde::__private::Ok(__Field::__field0),
                            b"Deactivate" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ToggleAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ToggleAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ToggleAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ToggleAction::Activate)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ToggleAction::Deactivate)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Activate", "Deactivate"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ToggleAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ToggleAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ToggleAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ToggleAction::Activate => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ToggleAction",
                            0u32,
                            "Activate",
                        )
                    }
                    ToggleAction::Deactivate => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ToggleAction",
                            1u32,
                            "Deactivate",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ToggleAction {
        #[inline]
        fn default() -> ToggleAction {
            Self::Activate
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ToggleAction {
        #[inline]
        fn clone(&self) -> ToggleAction {
            match self {
                ToggleAction::Activate => ToggleAction::Activate,
                ToggleAction::Deactivate => ToggleAction::Deactivate,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ToggleAction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ToggleAction::Activate => "Activate",
                    ToggleAction::Deactivate => "Deactivate",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ToggleAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ToggleAction {
        #[inline]
        fn eq(&self, other: &ToggleAction) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ToggleAction {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ToggleAction {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl From<ToggleAction> for ChainState {
        fn from(value: ToggleAction) -> Self {
            match value {
                ToggleAction::Activate => ChainState::Active,
                ToggleAction::Deactivate => ChainState::Deactive,
            }
        }
    }
    pub enum TxAction {
        #[default]
        Transfer,
        Redeem,
    }
    impl ::candid::types::CandidType for TxAction {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Redeem".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Transfer".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TxAction>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                TxAction::Redeem => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                TxAction::Transfer => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TxAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Transfer" => _serde::__private::Ok(__Field::__field0),
                            "Redeem" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Transfer" => _serde::__private::Ok(__Field::__field0),
                            b"Redeem" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TxAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TxAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TxAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TxAction::Transfer)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TxAction::Redeem)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Transfer", "Redeem"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TxAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TxAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TxAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TxAction::Transfer => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TxAction",
                            0u32,
                            "Transfer",
                        )
                    }
                    TxAction::Redeem => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TxAction",
                            1u32,
                            "Redeem",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TxAction {
        #[inline]
        fn default() -> TxAction {
            Self::Transfer
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TxAction {
        #[inline]
        fn clone(&self) -> TxAction {
            match self {
                TxAction::Transfer => TxAction::Transfer,
                TxAction::Redeem => TxAction::Redeem,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TxAction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TxAction::Transfer => "Transfer",
                    TxAction::Redeem => "Redeem",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TxAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TxAction {
        #[inline]
        fn eq(&self, other: &TxAction) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TxAction {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TxAction {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TxAction {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TxAction,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TxAction {
        #[inline]
        fn cmp(&self, other: &TxAction) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TxAction {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    pub enum Factor {
        UpdateTargetChainFactor(TargetChainFactor),
        UpdateFeeTokenFactor(FeeTokenFactor),
    }
    impl ::candid::types::CandidType for Factor {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "UpdateFeeTokenFactor".to_owned(),
                                    )
                                    .into(),
                                ty: <FeeTokenFactor as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "UpdateTargetChainFactor".to_owned(),
                                    )
                                    .into(),
                                ty: <TargetChainFactor as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Factor>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Factor::UpdateFeeTokenFactor(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Factor::UpdateTargetChainFactor(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Factor {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UpdateTargetChainFactor" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "UpdateFeeTokenFactor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UpdateTargetChainFactor" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"UpdateFeeTokenFactor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Factor>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Factor;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Factor",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        TargetChainFactor,
                                    >(__variant),
                                    Factor::UpdateTargetChainFactor,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        FeeTokenFactor,
                                    >(__variant),
                                    Factor::UpdateFeeTokenFactor,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "UpdateTargetChainFactor",
                    "UpdateFeeTokenFactor",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Factor",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Factor>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Factor {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Factor::UpdateTargetChainFactor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Factor",
                            0u32,
                            "UpdateTargetChainFactor",
                            __field0,
                        )
                    }
                    Factor::UpdateFeeTokenFactor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Factor",
                            1u32,
                            "UpdateFeeTokenFactor",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Factor {
        #[inline]
        fn clone(&self) -> Factor {
            match self {
                Factor::UpdateTargetChainFactor(__self_0) => {
                    Factor::UpdateTargetChainFactor(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                Factor::UpdateFeeTokenFactor(__self_0) => {
                    Factor::UpdateFeeTokenFactor(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Factor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Factor::UpdateTargetChainFactor(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UpdateTargetChainFactor",
                        &__self_0,
                    )
                }
                Factor::UpdateFeeTokenFactor(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UpdateFeeTokenFactor",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Factor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Factor {
        #[inline]
        fn eq(&self, other: &Factor) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        Factor::UpdateTargetChainFactor(__self_0),
                        Factor::UpdateTargetChainFactor(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Factor::UpdateFeeTokenFactor(__self_0),
                        Factor::UpdateFeeTokenFactor(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Factor {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Factor {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TargetChainFactor>;
            let _: ::core::cmp::AssertParamIsEq<FeeTokenFactor>;
        }
    }
    impl Storable for Factor {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let fee = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            fee
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl core::fmt::Display for Factor {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            match self {
                Factor::UpdateTargetChainFactor(chain_factor) => {
                    f.write_fmt(format_args!("{0}", chain_factor))
                }
                Factor::UpdateFeeTokenFactor(token_factor) => {
                    f.write_fmt(format_args!("{0}", token_factor))
                }
            }
        }
    }
    pub struct TargetChainFactor {
        pub target_chain_id: ChainId,
        pub target_chain_factor: u128,
    }
    impl ::candid::types::CandidType for TargetChainFactor {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "target_chain_id".to_string(),
                                    )
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "target_chain_factor".to_string(),
                                    )
                                    .into(),
                                ty: <u128 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TargetChainFactor>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.target_chain_id,
            )?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.target_chain_factor,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TargetChainFactor {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "target_chain_id" => _serde::__private::Ok(__Field::__field0),
                            "target_chain_factor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"target_chain_id" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"target_chain_factor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TargetChainFactor>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TargetChainFactor;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TargetChainFactor",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TargetChainFactor with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TargetChainFactor with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TargetChainFactor {
                            target_chain_id: __field0,
                            target_chain_factor: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u128> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "target_chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "target_chain_factor",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u128>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("target_chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("target_chain_factor")?
                            }
                        };
                        _serde::__private::Ok(TargetChainFactor {
                            target_chain_id: __field0,
                            target_chain_factor: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "target_chain_id",
                    "target_chain_factor",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TargetChainFactor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TargetChainFactor>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TargetChainFactor {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TargetChainFactor",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "target_chain_id",
                    &self.target_chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "target_chain_factor",
                    &self.target_chain_factor,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TargetChainFactor {
        #[inline]
        fn clone(&self) -> TargetChainFactor {
            TargetChainFactor {
                target_chain_id: ::core::clone::Clone::clone(&self.target_chain_id),
                target_chain_factor: ::core::clone::Clone::clone(
                    &self.target_chain_factor,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TargetChainFactor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TargetChainFactor",
                "target_chain_id",
                &self.target_chain_id,
                "target_chain_factor",
                &&self.target_chain_factor,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TargetChainFactor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TargetChainFactor {
        #[inline]
        fn eq(&self, other: &TargetChainFactor) -> bool {
            self.target_chain_id == other.target_chain_id
                && self.target_chain_factor == other.target_chain_factor
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TargetChainFactor {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TargetChainFactor {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<u128>;
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for TargetChainFactor {
        #[inline]
        fn default() -> TargetChainFactor {
            TargetChainFactor {
                target_chain_id: ::core::default::Default::default(),
                target_chain_factor: ::core::default::Default::default(),
            }
        }
    }
    impl Storable for TargetChainFactor {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let fee = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            fee
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl core::fmt::Display for TargetChainFactor {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\nchain id:{0},\nchain factor:{1}",
                    self.target_chain_id,
                    self.target_chain_factor,
                ),
            )
        }
    }
    pub struct FeeTokenFactor {
        pub fee_token: TokenId,
        pub fee_token_factor: u128,
    }
    impl ::candid::types::CandidType for FeeTokenFactor {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("fee_token".to_string())
                                    .into(),
                                ty: <TokenId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "fee_token_factor".to_string(),
                                    )
                                    .into(),
                                ty: <u128 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<FeeTokenFactor>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.fee_token)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.fee_token_factor,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeeTokenFactor {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "fee_token" => _serde::__private::Ok(__Field::__field0),
                            "fee_token_factor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"fee_token" => _serde::__private::Ok(__Field::__field0),
                            b"fee_token_factor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeeTokenFactor>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeeTokenFactor;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeeTokenFactor",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TokenId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeeTokenFactor with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FeeTokenFactor with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeeTokenFactor {
                            fee_token: __field0,
                            fee_token_factor: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<TokenId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u128> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fee_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TokenId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fee_token_factor",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u128>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fee_token")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fee_token_factor")?
                            }
                        };
                        _serde::__private::Ok(FeeTokenFactor {
                            fee_token: __field0,
                            fee_token_factor: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "fee_token",
                    "fee_token_factor",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeeTokenFactor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeeTokenFactor>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeeTokenFactor {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeeTokenFactor",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fee_token",
                    &self.fee_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fee_token_factor",
                    &self.fee_token_factor,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for FeeTokenFactor {
        #[inline]
        fn clone(&self) -> FeeTokenFactor {
            FeeTokenFactor {
                fee_token: ::core::clone::Clone::clone(&self.fee_token),
                fee_token_factor: ::core::clone::Clone::clone(&self.fee_token_factor),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeeTokenFactor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FeeTokenFactor",
                "fee_token",
                &self.fee_token,
                "fee_token_factor",
                &&self.fee_token_factor,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeeTokenFactor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeeTokenFactor {
        #[inline]
        fn eq(&self, other: &FeeTokenFactor) -> bool {
            self.fee_token == other.fee_token
                && self.fee_token_factor == other.fee_token_factor
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FeeTokenFactor {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FeeTokenFactor {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TokenId>;
            let _: ::core::cmp::AssertParamIsEq<u128>;
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FeeTokenFactor {
        #[inline]
        fn default() -> FeeTokenFactor {
            FeeTokenFactor {
                fee_token: ::core::default::Default::default(),
                fee_token_factor: ::core::default::Default::default(),
            }
        }
    }
    impl Storable for FeeTokenFactor {
        fn to_bytes(&self) -> Cow<[u8]> {
            let mut bytes = ::alloc::vec::Vec::new();
            let _ = ciborium::ser::into_writer(self, &mut bytes);
            Cow::Owned(bytes)
        }
        fn from_bytes(bytes: Cow<[u8]>) -> Self {
            let fee = ciborium::de::from_reader(bytes.as_ref())
                .expect("failed to decode TokenKey");
            fee
        }
        const BOUND: Bound = Bound::Unbounded;
    }
    impl core::fmt::Display for FeeTokenFactor {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\nfee token:{0},\nfee_token_factor:{1}",
                    self.fee_token,
                    self.fee_token_factor,
                ),
            )
        }
    }
    /// chain id spec:
    /// for settlement chain, the chain id is: Bitcoin, Ethereum,or ICP
    /// for execution chain, the chain id spec is: type-chain_name,eg: EVM-Base,Cosmos-Gaia, Substrate-Xxx
    pub struct Chain {
        pub chain_id: ChainId,
        pub canister_id: String,
        pub chain_type: ChainType,
        pub chain_state: ChainState,
        pub contract_address: Option<String>,
        pub counterparties: Option<Vec<ChainId>>,
        pub fee_token: Option<TokenId>,
    }
    impl ::candid::types::CandidType for Chain {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("fee_token".to_string())
                                    .into(),
                                ty: <Option<TokenId> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("canister_id".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "counterparties".to_string(),
                                    )
                                    .into(),
                                ty: <Option<
                                    Vec<ChainId>,
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_state".to_string())
                                    .into(),
                                ty: <ChainState as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_type".to_string())
                                    .into(),
                                ty: <ChainType as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "contract_address".to_string(),
                                    )
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Chain>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.fee_token)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.canister_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.counterparties,
            )?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_state)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_type)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.contract_address,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Chain {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_id" => _serde::__private::Ok(__Field::__field0),
                            "canister_id" => _serde::__private::Ok(__Field::__field1),
                            "chain_type" => _serde::__private::Ok(__Field::__field2),
                            "chain_state" => _serde::__private::Ok(__Field::__field3),
                            "contract_address" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "counterparties" => _serde::__private::Ok(__Field::__field5),
                            "fee_token" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"canister_id" => _serde::__private::Ok(__Field::__field1),
                            b"chain_type" => _serde::__private::Ok(__Field::__field2),
                            b"chain_state" => _serde::__private::Ok(__Field::__field3),
                            b"contract_address" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"counterparties" => _serde::__private::Ok(__Field::__field5),
                            b"fee_token" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Chain>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Chain;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Chain",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ChainType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ChainState,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<Vec<ChainId>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<TokenId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Chain with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Chain {
                            chain_id: __field0,
                            canister_id: __field1,
                            chain_type: __field2,
                            chain_state: __field3,
                            contract_address: __field4,
                            counterparties: __field5,
                            fee_token: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<ChainType> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<ChainState> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Option<Vec<ChainId>>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<TokenId>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "canister_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_type",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainType>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_state",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainState>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contract_address",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "counterparties",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Vec<ChainId>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fee_token",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TokenId>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("canister_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_type")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_state")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("contract_address")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("counterparties")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fee_token")?
                            }
                        };
                        _serde::__private::Ok(Chain {
                            chain_id: __field0,
                            canister_id: __field1,
                            chain_type: __field2,
                            chain_state: __field3,
                            contract_address: __field4,
                            counterparties: __field5,
                            fee_token: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "chain_id",
                    "canister_id",
                    "chain_type",
                    "chain_state",
                    "contract_address",
                    "counterparties",
                    "fee_token",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Chain",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Chain>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Chain {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Chain",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "canister_id",
                    &self.canister_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_type",
                    &self.chain_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_state",
                    &self.chain_state,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contract_address",
                    &self.contract_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "counterparties",
                    &self.counterparties,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fee_token",
                    &self.fee_token,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Chain {
        #[inline]
        fn clone(&self) -> Chain {
            Chain {
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                canister_id: ::core::clone::Clone::clone(&self.canister_id),
                chain_type: ::core::clone::Clone::clone(&self.chain_type),
                chain_state: ::core::clone::Clone::clone(&self.chain_state),
                contract_address: ::core::clone::Clone::clone(&self.contract_address),
                counterparties: ::core::clone::Clone::clone(&self.counterparties),
                fee_token: ::core::clone::Clone::clone(&self.fee_token),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Chain {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "chain_id",
                "canister_id",
                "chain_type",
                "chain_state",
                "contract_address",
                "counterparties",
                "fee_token",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.chain_id,
                &self.canister_id,
                &self.chain_type,
                &self.chain_state,
                &self.contract_address,
                &self.counterparties,
                &&self.fee_token,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Chain", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Chain {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Chain {
        #[inline]
        fn eq(&self, other: &Chain) -> bool {
            self.chain_id == other.chain_id && self.canister_id == other.canister_id
                && self.chain_type == other.chain_type
                && self.chain_state == other.chain_state
                && self.contract_address == other.contract_address
                && self.counterparties == other.counterparties
                && self.fee_token == other.fee_token
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Chain {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Chain {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<ChainType>;
            let _: ::core::cmp::AssertParamIsEq<ChainState>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Vec<ChainId>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<TokenId>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Chain {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.chain_id, state);
            ::core::hash::Hash::hash(&self.canister_id, state);
            ::core::hash::Hash::hash(&self.chain_type, state);
            ::core::hash::Hash::hash(&self.chain_state, state);
            ::core::hash::Hash::hash(&self.contract_address, state);
            ::core::hash::Hash::hash(&self.counterparties, state);
            ::core::hash::Hash::hash(&self.fee_token, state)
        }
    }
    impl Chain {
        pub fn chain_name(&self) -> Option<&str> {
            match self.chain_type {
                ChainType::SettlementChain => Some(&self.chain_id),
                ChainType::ExecutionChain => self.chain_id.split('-').last(),
            }
        }
    }
    impl core::fmt::Display for Chain {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\nchain id:{0} \ncanister id:{1} \nchain type:{2:?} \nchain state:{3:?} \ncontract address:{4:?} \ncounterparties:{5:?} \nfee_token:{6:?}",
                    self.chain_id,
                    self.canister_id,
                    self.chain_type,
                    self.chain_state,
                    self.contract_address,
                    self.counterparties,
                    self.fee_token,
                ),
            )
        }
    }
    pub struct ToggleState {
        pub chain_id: ChainId,
        pub action: ToggleAction,
    }
    impl ::candid::types::CandidType for ToggleState {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("action".to_string())
                                    .into(),
                                ty: <ToggleAction as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ToggleState>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.action)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ToggleState {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_id" => _serde::__private::Ok(__Field::__field0),
                            "action" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"action" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ToggleState>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ToggleState;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ToggleState",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ToggleState with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ToggleAction,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ToggleState with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ToggleState {
                            chain_id: __field0,
                            action: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<ToggleAction> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ToggleAction,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        _serde::__private::Ok(ToggleState {
                            chain_id: __field0,
                            action: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["chain_id", "action"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ToggleState",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ToggleState>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ToggleState {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ToggleState",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ToggleState {
        #[inline]
        fn default() -> ToggleState {
            ToggleState {
                chain_id: ::core::default::Default::default(),
                action: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ToggleState {
        #[inline]
        fn clone(&self) -> ToggleState {
            ToggleState {
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                action: ::core::clone::Clone::clone(&self.action),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ToggleState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ToggleState",
                "chain_id",
                &self.chain_id,
                "action",
                &&self.action,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ToggleState {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ToggleState {
        #[inline]
        fn eq(&self, other: &ToggleState) -> bool {
            self.chain_id == other.chain_id && self.action == other.action
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ToggleState {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ToggleState {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<ToggleAction>;
        }
    }
    impl core::fmt::Display for ToggleState {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\nchain:{0},\nchain state:{1:?}",
                    self.chain_id,
                    self.action,
                ),
            )
        }
    }
    /// metadata stores extended information，for runes protocol token, it stores the runes id
    pub struct Token {
        pub token_id: TokenId,
        pub name: String,
        pub symbol: String,
        pub decimals: u8,
        pub icon: Option<String>,
        pub metadata: HashMap<String, String>,
    }
    impl ::candid::types::CandidType for Token {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("decimals".to_string())
                                    .into(),
                                ty: <u8 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token_id".to_string())
                                    .into(),
                                ty: <TokenId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("metadata".to_string())
                                    .into(),
                                ty: <HashMap<
                                    String,
                                    String,
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("icon".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("name".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("symbol".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Token>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.decimals)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.metadata)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.icon)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.name)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.symbol)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Token {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "name" => _serde::__private::Ok(__Field::__field1),
                            "symbol" => _serde::__private::Ok(__Field::__field2),
                            "decimals" => _serde::__private::Ok(__Field::__field3),
                            "icon" => _serde::__private::Ok(__Field::__field4),
                            "metadata" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"name" => _serde::__private::Ok(__Field::__field1),
                            b"symbol" => _serde::__private::Ok(__Field::__field2),
                            b"decimals" => _serde::__private::Ok(__Field::__field3),
                            b"icon" => _serde::__private::Ok(__Field::__field4),
                            b"metadata" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Token>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Token;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Token",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TokenId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            HashMap<String, String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Token with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Token {
                            token_id: __field0,
                            name: __field1,
                            symbol: __field2,
                            decimals: __field3,
                            icon: __field4,
                            metadata: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<TokenId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            HashMap<String, String>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TokenId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("symbol"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "decimals",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("icon"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "metadata",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            HashMap<String, String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("symbol")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("decimals")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("icon")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("metadata")?
                            }
                        };
                        _serde::__private::Ok(Token {
                            token_id: __field0,
                            name: __field1,
                            symbol: __field2,
                            decimals: __field3,
                            icon: __field4,
                            metadata: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "name",
                    "symbol",
                    "decimals",
                    "icon",
                    "metadata",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Token",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Token>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Token {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Token",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "symbol",
                    &self.symbol,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "decimals",
                    &self.decimals,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "icon",
                    &self.icon,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "metadata",
                    &self.metadata,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for Token {
        #[inline]
        fn clone(&self) -> Token {
            Token {
                token_id: ::core::clone::Clone::clone(&self.token_id),
                name: ::core::clone::Clone::clone(&self.name),
                symbol: ::core::clone::Clone::clone(&self.symbol),
                decimals: ::core::clone::Clone::clone(&self.decimals),
                icon: ::core::clone::Clone::clone(&self.icon),
                metadata: ::core::clone::Clone::clone(&self.metadata),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Token {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "token_id",
                "name",
                "symbol",
                "decimals",
                "icon",
                "metadata",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.token_id,
                &self.name,
                &self.symbol,
                &self.decimals,
                &self.icon,
                &&self.metadata,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Token", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Token {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Token {
        #[inline]
        fn eq(&self, other: &Token) -> bool {
            self.token_id == other.token_id && self.name == other.name
                && self.symbol == other.symbol && self.decimals == other.decimals
                && self.icon == other.icon && self.metadata == other.metadata
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Token {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Token {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TokenId>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<u8>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<HashMap<String, String>>;
        }
    }
    impl Token {
        /// return (settlmentchain,token protocol, token symbol)
        pub fn token_id_info(&self) -> Vec<&str> {
            self.token_id.split('-').collect()
        }
    }
    impl core::fmt::Display for Token {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
            f.write_fmt(
                format_args!(
                    "\ttoken id:{0} \ntoken name:{1} \nsymbol:{2:?} \ndecimals:{3} \nicon:{4:?} \nmetadata:{5:?}",
                    self.token_id,
                    self.name,
                    self.symbol,
                    self.decimals,
                    self.icon,
                    self.metadata,
                ),
            )
        }
    }
    pub struct TokenOnChain {
        pub chain_id: ChainId,
        pub token_id: TokenId,
        pub amount: u128,
    }
    impl ::candid::types::CandidType for TokenOnChain {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token_id".to_string())
                                    .into(),
                                ty: <TokenId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <ChainId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("amount".to_string())
                                    .into(),
                                ty: <u128 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TokenOnChain>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.amount)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenOnChain {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_id" => _serde::__private::Ok(__Field::__field0),
                            "token_id" => _serde::__private::Ok(__Field::__field1),
                            "amount" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_id" => _serde::__private::Ok(__Field::__field0),
                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                            b"amount" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TokenOnChain>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenOnChain;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TokenOnChain",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ChainId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TokenOnChain with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TokenId,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenOnChain with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TokenOnChain with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TokenOnChain {
                            chain_id: __field0,
                            token_id: __field1,
                            amount: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ChainId> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u128> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ChainId>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TokenId>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u128>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        _serde::__private::Ok(TokenOnChain {
                            chain_id: __field0,
                            token_id: __field1,
                            amount: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "chain_id",
                    "token_id",
                    "amount",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenOnChain",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TokenOnChain>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenOnChain {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenOnChain",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TokenOnChain {
        #[inline]
        fn clone(&self) -> TokenOnChain {
            TokenOnChain {
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
                token_id: ::core::clone::Clone::clone(&self.token_id),
                amount: ::core::clone::Clone::clone(&self.amount),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenOnChain {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TokenOnChain",
                "chain_id",
                &self.chain_id,
                "token_id",
                &self.token_id,
                "amount",
                &&self.amount,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TokenOnChain {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TokenOnChain {
        #[inline]
        fn eq(&self, other: &TokenOnChain) -> bool {
            self.chain_id == other.chain_id && self.token_id == other.token_id
                && self.amount == other.amount
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TokenOnChain {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TokenOnChain {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ChainId>;
            let _: ::core::cmp::AssertParamIsEq<TokenId>;
            let _: ::core::cmp::AssertParamIsEq<u128>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TokenOnChain {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.chain_id, state);
            ::core::hash::Hash::hash(&self.token_id, state);
            ::core::hash::Hash::hash(&self.amount, state)
        }
    }
    pub struct ChainCondition {
        pub chain_type: Option<ChainType>,
        pub chain_state: Option<ChainState>,
    }
    impl ::candid::types::CandidType for ChainCondition {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_state".to_string())
                                    .into(),
                                ty: <Option<
                                    ChainState,
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_type".to_string())
                                    .into(),
                                ty: <Option<ChainType> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ChainCondition>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_state)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_type)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ChainCondition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "chain_type" => _serde::__private::Ok(__Field::__field0),
                            "chain_state" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"chain_type" => _serde::__private::Ok(__Field::__field0),
                            b"chain_state" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ChainCondition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ChainCondition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ChainCondition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<ChainType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ChainCondition with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ChainState>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ChainCondition with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ChainCondition {
                            chain_type: __field0,
                            chain_state: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<ChainType>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ChainState>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ChainType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_state",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ChainState>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_state")?
                            }
                        };
                        _serde::__private::Ok(ChainCondition {
                            chain_type: __field0,
                            chain_state: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["chain_type", "chain_state"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ChainCondition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ChainCondition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ChainCondition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ChainCondition",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_type",
                    &self.chain_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_state",
                    &self.chain_state,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ChainCondition {
        #[inline]
        fn default() -> ChainCondition {
            ChainCondition {
                chain_type: ::core::default::Default::default(),
                chain_state: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChainCondition {
        #[inline]
        fn clone(&self) -> ChainCondition {
            ChainCondition {
                chain_type: ::core::clone::Clone::clone(&self.chain_type),
                chain_state: ::core::clone::Clone::clone(&self.chain_state),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ChainCondition {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ChainCondition",
                "chain_type",
                &self.chain_type,
                "chain_state",
                &&self.chain_state,
            )
        }
    }
    pub struct TokenCondition {
        pub token_id: Option<TokenId>,
        pub chain_id: Option<ChainId>,
    }
    impl ::candid::types::CandidType for TokenCondition {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token_id".to_string())
                                    .into(),
                                ty: <Option<TokenId> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_id".to_string())
                                    .into(),
                                ty: <Option<ChainId> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TokenCondition>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_id)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenCondition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "chain_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"chain_id" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TokenCondition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenCondition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TokenCondition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<TokenId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TokenCondition with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ChainId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenCondition with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TokenCondition {
                            token_id: __field0,
                            chain_id: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<TokenId>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<ChainId>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TokenId>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ChainId>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_id")?
                            }
                        };
                        _serde::__private::Ok(TokenCondition {
                            token_id: __field0,
                            chain_id: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["token_id", "chain_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenCondition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TokenCondition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenCondition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenCondition",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chain_id",
                    &self.chain_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TokenCondition {
        #[inline]
        fn clone(&self) -> TokenCondition {
            TokenCondition {
                token_id: ::core::clone::Clone::clone(&self.token_id),
                chain_id: ::core::clone::Clone::clone(&self.chain_id),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenCondition {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TokenCondition",
                "token_id",
                &self.token_id,
                "chain_id",
                &&self.chain_id,
            )
        }
    }
    pub struct TxCondition {
        pub src_chain: Option<ChainId>,
        pub dst_chain: Option<ChainId>,
        pub token_id: Option<TokenId>,
        pub time_range: Option<(u64, u64)>,
    }
    impl ::candid::types::CandidType for TxCondition {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token_id".to_string())
                                    .into(),
                                ty: <Option<TokenId> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("dst_chain".to_string())
                                    .into(),
                                ty: <Option<ChainId> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("time_range".to_string())
                                    .into(),
                                ty: <Option<
                                    (u64, u64),
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("src_chain".to_string())
                                    .into(),
                                ty: <Option<ChainId> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<TxCondition>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.dst_chain)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.time_range)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.src_chain)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TxCondition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "src_chain" => _serde::__private::Ok(__Field::__field0),
                            "dst_chain" => _serde::__private::Ok(__Field::__field1),
                            "token_id" => _serde::__private::Ok(__Field::__field2),
                            "time_range" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"src_chain" => _serde::__private::Ok(__Field::__field0),
                            b"dst_chain" => _serde::__private::Ok(__Field::__field1),
                            b"token_id" => _serde::__private::Ok(__Field::__field2),
                            b"time_range" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TxCondition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TxCondition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TxCondition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<ChainId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TxCondition with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ChainId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TxCondition with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<TokenId>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TxCondition with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<(u64, u64)>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TxCondition with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TxCondition {
                            src_chain: __field0,
                            dst_chain: __field1,
                            token_id: __field2,
                            time_range: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<ChainId>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<ChainId>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<TokenId>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Option<(u64, u64)>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "src_chain",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ChainId>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dst_chain",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ChainId>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TokenId>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "time_range",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<(u64, u64)>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("src_chain")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dst_chain")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("time_range")?
                            }
                        };
                        _serde::__private::Ok(TxCondition {
                            src_chain: __field0,
                            dst_chain: __field1,
                            token_id: __field2,
                            time_range: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "src_chain",
                    "dst_chain",
                    "token_id",
                    "time_range",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TxCondition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TxCondition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TxCondition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TxCondition",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "src_chain",
                    &self.src_chain,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dst_chain",
                    &self.dst_chain,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "time_range",
                    &self.time_range,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TxCondition {
        #[inline]
        fn clone(&self) -> TxCondition {
            TxCondition {
                src_chain: ::core::clone::Clone::clone(&self.src_chain),
                dst_chain: ::core::clone::Clone::clone(&self.dst_chain),
                token_id: ::core::clone::Clone::clone(&self.token_id),
                time_range: ::core::clone::Clone::clone(&self.time_range),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TxCondition {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TxCondition",
                "src_chain",
                &self.src_chain,
                "dst_chain",
                &self.dst_chain,
                "token_id",
                &self.token_id,
                "time_range",
                &&self.time_range,
            )
        }
    }
    use crate::state::read_state;
    use candid::Principal;
    use cketh_common::eth_rpc::LogEntry;
    use ic_cdk::api::management_canister::ecdsa::{EcdsaCurve, EcdsaKeyId};
    use crate::contracts::omnity_port_contract::TokenBurnedFilter;
    use crate::contracts::TokenTransportRequestedFilter;
    pub type CanisterId = Principal;
    struct ECDSAPublicKey {
        pub canister_id: Option<CanisterId>,
        pub derivation_path: Vec<Vec<u8>>,
        pub key_id: EcdsaKeyId,
    }
    impl ::candid::types::CandidType for ECDSAPublicKey {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("key_id".to_string())
                                    .into(),
                                ty: <EcdsaKeyId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("canister_id".to_string())
                                    .into(),
                                ty: <Option<
                                    CanisterId,
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "derivation_path".to_string(),
                                    )
                                    .into(),
                                ty: <Vec<Vec<u8>> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ECDSAPublicKey>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.key_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.canister_id)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.derivation_path,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ECDSAPublicKey {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ECDSAPublicKey",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "canister_id",
                    &self.canister_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "derivation_path",
                    &self.derivation_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key_id",
                    &self.key_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ECDSAPublicKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ECDSAPublicKey",
                "canister_id",
                &self.canister_id,
                "derivation_path",
                &self.derivation_path,
                "key_id",
                &&self.key_id,
            )
        }
    }
    pub struct ECDSAPublicKeyReply {
        pub public_key: Vec<u8>,
        pub chain_code: Vec<u8>,
    }
    impl ::candid::types::CandidType for ECDSAPublicKeyReply {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("public_key".to_string())
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("chain_code".to_string())
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ECDSAPublicKeyReply>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.public_key)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.chain_code)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ECDSAPublicKeyReply {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "public_key" => _serde::__private::Ok(__Field::__field0),
                            "chain_code" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"public_key" => _serde::__private::Ok(__Field::__field0),
                            b"chain_code" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ECDSAPublicKeyReply>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ECDSAPublicKeyReply;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ECDSAPublicKeyReply",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ECDSAPublicKeyReply with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ECDSAPublicKeyReply with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ECDSAPublicKeyReply {
                            public_key: __field0,
                            chain_code: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "public_key",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chain_code",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("public_key")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("chain_code")?
                            }
                        };
                        _serde::__private::Ok(ECDSAPublicKeyReply {
                            public_key: __field0,
                            chain_code: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["public_key", "chain_code"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ECDSAPublicKeyReply",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ECDSAPublicKeyReply>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ECDSAPublicKeyReply {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ECDSAPublicKeyReply",
                "public_key",
                &self.public_key,
                "chain_code",
                &&self.chain_code,
            )
        }
    }
    pub struct SignWithECDSA {
        pub message_hash: Vec<u8>,
        pub derivation_path: Vec<Vec<u8>>,
        pub key_id: EcdsaKeyId,
    }
    impl ::candid::types::CandidType for SignWithECDSA {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("key_id".to_string())
                                    .into(),
                                ty: <EcdsaKeyId as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "derivation_path".to_string(),
                                    )
                                    .into(),
                                ty: <Vec<Vec<u8>> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "message_hash".to_string(),
                                    )
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<SignWithECDSA>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.key_id)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.derivation_path,
            )?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.message_hash)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SignWithECDSA {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SignWithECDSA",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "message_hash",
                    &self.message_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "derivation_path",
                    &self.derivation_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key_id",
                    &self.key_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SignWithECDSA {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "SignWithECDSA",
                "message_hash",
                &self.message_hash,
                "derivation_path",
                &self.derivation_path,
                "key_id",
                &&self.key_id,
            )
        }
    }
    pub struct SignWithECDSAReply {
        pub signature: Vec<u8>,
    }
    impl ::candid::types::CandidType for SignWithECDSAReply {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("signature".to_string())
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<SignWithECDSAReply>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.signature)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SignWithECDSAReply {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "signature" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"signature" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SignWithECDSAReply>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SignWithECDSAReply;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct SignWithECDSAReply",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SignWithECDSAReply with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(SignWithECDSAReply {
                            signature: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "signature",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("signature")?
                            }
                        };
                        _serde::__private::Ok(SignWithECDSAReply {
                            signature: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["signature"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SignWithECDSAReply",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SignWithECDSAReply>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SignWithECDSAReply {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "SignWithECDSAReply",
                "signature",
                &&self.signature,
            )
        }
    }
    pub struct PublicKeyReply {
        pub public_key: Vec<u8>,
    }
    impl ::candid::types::CandidType for PublicKeyReply {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("public_key".to_string())
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<PublicKeyReply>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.public_key)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PublicKeyReply {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PublicKeyReply",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "public_key",
                    &self.public_key,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for PublicKeyReply {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "PublicKeyReply",
                "public_key",
                &&self.public_key,
            )
        }
    }
    impl From<Vec<u8>> for PublicKeyReply {
        fn from(public_key: Vec<u8>) -> Self {
            Self { public_key }
        }
    }
    pub struct SignatureReply {
        pub signature: Vec<u8>,
    }
    impl ::candid::types::CandidType for SignatureReply {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("signature".to_string())
                                    .into(),
                                ty: <Vec<u8> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<SignatureReply>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.signature)?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SignatureReply {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SignatureReply",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "signature",
                    &self.signature,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SignatureReply {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "SignatureReply",
                "signature",
                &&self.signature,
            )
        }
    }
    impl From<Vec<u8>> for SignatureReply {
        fn from(signature: Vec<u8>) -> Self {
            Self { signature }
        }
    }
    pub struct SignatureVerificationReply {
        pub is_signature_valid: bool,
    }
    impl ::candid::types::CandidType for SignatureVerificationReply {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "is_signature_valid".to_string(),
                                    )
                                    .into(),
                                ty: <bool as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<SignatureVerificationReply>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.is_signature_valid,
            )?;
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SignatureVerificationReply {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SignatureVerificationReply",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_signature_valid",
                    &self.is_signature_valid,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SignatureVerificationReply {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "SignatureVerificationReply",
                "is_signature_valid",
                &&self.is_signature_valid,
            )
        }
    }
    impl From<bool> for SignatureVerificationReply {
        fn from(is_signature_valid: bool) -> Self {
            Self { is_signature_valid }
        }
    }
    pub enum EcdsaKeyIds {
        #[allow(unused)]
        TestKeyLocalDevelopment,
        #[allow(unused)]
        TestKey1,
        #[allow(unused)]
        ProductionKey1,
    }
    impl EcdsaKeyIds {
        pub fn to_key_id(&self) -> EcdsaKeyId {
            EcdsaKeyId {
                curve: EcdsaCurve::Secp256k1,
                name: match self {
                    Self::TestKeyLocalDevelopment => "dfx_test_key",
                    Self::TestKey1 => "test_key_1",
                    Self::ProductionKey1 => "key_1",
                }
                    .to_string(),
            }
        }
    }
    pub enum Network {
        #[serde(rename = "local")]
        Local,
        #[serde(rename = "testnet")]
        Testnet,
        #[serde(rename = "mainnet")]
        Mainnet,
    }
    impl ::candid::types::CandidType for Network {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("mainnet".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("local".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("testnet".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Network>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Network::Mainnet => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                Network::Local => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                Network::Testnet => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Network {
        #[inline]
        fn clone(&self) -> Network {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Network {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Network {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "local" => _serde::__private::Ok(__Field::__field0),
                            "testnet" => _serde::__private::Ok(__Field::__field1),
                            "mainnet" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"local" => _serde::__private::Ok(__Field::__field0),
                            b"testnet" => _serde::__private::Ok(__Field::__field1),
                            b"mainnet" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Network>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Network;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Network",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Network::Local)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Network::Testnet)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Network::Mainnet)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "local",
                    "testnet",
                    "mainnet",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Network",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Network>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Network {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Network::Local => "Local",
                    Network::Testnet => "Testnet",
                    Network::Mainnet => "Mainnet",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Network {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Network {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Network {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Network {
        #[inline]
        fn eq(&self, other: &Network) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Network {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Network::Local => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Network",
                            0u32,
                            "local",
                        )
                    }
                    Network::Testnet => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Network",
                            1u32,
                            "testnet",
                        )
                    }
                    Network::Mainnet => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Network",
                            2u32,
                            "mainnet",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::hash::Hash for Network {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl Network {
        pub fn key_id(&self) -> EcdsaKeyId {
            match self {
                Network::Local => EcdsaKeyIds::TestKeyLocalDevelopment.to_key_id(),
                Network::Testnet => EcdsaKeyIds::TestKey1.to_key_id(),
                Network::Mainnet => EcdsaKeyIds::ProductionKey1.to_key_id(),
            }
        }
    }
    impl core::fmt::Display for Network {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::Local => f.write_fmt(format_args!("local")),
                Self::Testnet => f.write_fmt(format_args!("testnet")),
                Self::Mainnet => f.write_fmt(format_args!("mainnet")),
            }
        }
    }
    impl FromStr for Network {
        type Err = Error;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "regtest" => Ok(Network::Local),
                "testnet" => Ok(Network::Testnet),
                "mainnet" => Ok(Network::Mainnet),
                _ => Err(Error::CustomError("Bad network".to_string())),
            }
        }
    }
    pub enum Error {
        #[error("The chain(`{0}`) already exists")]
        ChainAlreadyExisting(String),
        #[error("The token(`{0}`) already exists")]
        TokenAlreadyExisting(String),
        #[error("not supported proposal")]
        NotSupportedProposal,
        #[error("proposal error: (`{0}`)")]
        ProposalError(String),
        #[error("generate directive error for : (`{0}`)")]
        GenerateDirectiveError(String),
        #[error("the message is malformed and cannot be decoded error")]
        MalformedMessageBytes,
        #[error("unauthorized")]
        Unauthorized,
        #[error("The `{0}` is deactive")]
        DeactiveChain(String),
        #[error("The ticket id (`{0}`) already exists!")]
        AlreadyExistingTicketId(String),
        #[error("The resubmit ticket id must exist!")]
        ResubmitTicketIdMustExist,
        #[error("The resubmit ticket must same as the old ticket!")]
        ResubmitTicketMustSame,
        #[error("The resumit ticket sent too often")]
        ResubmitTicketSentTooOften,
        #[error("not found chain: (`{0}`)")]
        NotFoundChain(String),
        #[error("not found token: (`{0}`)")]
        NotFoundToken(String),
        #[error("not found account(`{0}`) token(`{1}`) on the chain(`{2}`")]
        NotFoundAccountToken(String, String, String),
        #[error("Not found this token(`{0}`) on chain(`{1}`) ")]
        NotFoundChainToken(String, String),
        #[error("Insufficient token (`{0}`) on chain (`{1}`) !)")]
        NotSufficientTokens(String, String),
        #[error("The ticket amount(`{0}`) parse error: `{1}`")]
        TicketAmountParseError(String, String),
        #[error("ecdsa_public_key failed : (`{0}`)")]
        EcdsaPublicKeyError(String),
        #[error("sign_with_ecdsa failed: (`{0}`)")]
        SighWithEcdsaError(String),
        #[error("custom error: (`{0}`)")]
        CustomError(String),
    }
    impl ::candid::types::CandidType for Error {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "AlreadyExistingTicketId".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "MalformedMessageBytes".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotFoundChain".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "DeactiveChain".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ChainAlreadyExisting".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ResubmitTicketIdMustExist".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ProposalError".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ResubmitTicketMustSame".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotFoundAccountToken".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Record(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(0u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(1u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(2u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                            ]),
                                        ),
                                    )
                                    .into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotSupportedProposal".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "SighWithEcdsaError".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Unauthorized".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "TicketAmountParseError".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Record(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(0u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(1u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                            ]),
                                        ),
                                    )
                                    .into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotFoundChainToken".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Record(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(0u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(1u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                            ]),
                                        ),
                                    )
                                    .into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "TokenAlreadyExisting".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "ResubmitTicketSentTooOften".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "GenerateDirectiveError".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "EcdsaPublicKeyError".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotFoundToken".to_owned(),
                                    )
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("CustomError".to_owned())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "NotSufficientTokens".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Record(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(0u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                                ::candid::types::Field {
                                                    id: ::candid::types::Label::Id(1u32).into(),
                                                    ty: <String as ::candid::types::CandidType>::ty(),
                                                },
                                            ]),
                                        ),
                                    )
                                    .into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Error>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Error::AlreadyExistingTicketId(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::MalformedMessageBytes => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                Error::NotFoundChain(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::DeactiveChain(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(3u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::ChainAlreadyExisting(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(4u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::ResubmitTicketIdMustExist => {
                    let mut ser = __serializer.serialize_variant(5u64)?;
                }
                Error::ProposalError(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(6u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::ResubmitTicketMustSame => {
                    let mut ser = __serializer.serialize_variant(7u64)?;
                }
                Error::NotFoundAccountToken(
                    ref __field0,
                    ref __field1,
                    ref __field2,
                ) => {
                    let mut ser = __serializer.serialize_variant(8u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field1)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field2)?;
                }
                Error::NotSupportedProposal => {
                    let mut ser = __serializer.serialize_variant(9u64)?;
                }
                Error::SighWithEcdsaError(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(10u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::Unauthorized => {
                    let mut ser = __serializer.serialize_variant(11u64)?;
                }
                Error::TicketAmountParseError(ref __field0, ref __field1) => {
                    let mut ser = __serializer.serialize_variant(12u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field1)?;
                }
                Error::NotFoundChainToken(ref __field0, ref __field1) => {
                    let mut ser = __serializer.serialize_variant(13u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field1)?;
                }
                Error::TokenAlreadyExisting(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(14u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::ResubmitTicketSentTooOften => {
                    let mut ser = __serializer.serialize_variant(15u64)?;
                }
                Error::GenerateDirectiveError(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(16u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::EcdsaPublicKeyError(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(17u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::NotFoundToken(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(18u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::CustomError(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(19u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Error::NotSufficientTokens(ref __field0, ref __field1) => {
                    let mut ser = __serializer.serialize_variant(20u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field1)?;
                }
            };
            Ok(())
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Error {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 21",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "ChainAlreadyExisting" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "TokenAlreadyExisting" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "NotSupportedProposal" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "ProposalError" => _serde::__private::Ok(__Field::__field3),
                            "GenerateDirectiveError" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "MalformedMessageBytes" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "Unauthorized" => _serde::__private::Ok(__Field::__field6),
                            "DeactiveChain" => _serde::__private::Ok(__Field::__field7),
                            "AlreadyExistingTicketId" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "ResubmitTicketIdMustExist" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "ResubmitTicketMustSame" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "ResubmitTicketSentTooOften" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "NotFoundChain" => _serde::__private::Ok(__Field::__field12),
                            "NotFoundToken" => _serde::__private::Ok(__Field::__field13),
                            "NotFoundAccountToken" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            "NotFoundChainToken" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "NotSufficientTokens" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            "TicketAmountParseError" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            "EcdsaPublicKeyError" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            "SighWithEcdsaError" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            "CustomError" => _serde::__private::Ok(__Field::__field20),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"ChainAlreadyExisting" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"TokenAlreadyExisting" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"NotSupportedProposal" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"ProposalError" => _serde::__private::Ok(__Field::__field3),
                            b"GenerateDirectiveError" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"MalformedMessageBytes" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"Unauthorized" => _serde::__private::Ok(__Field::__field6),
                            b"DeactiveChain" => _serde::__private::Ok(__Field::__field7),
                            b"AlreadyExistingTicketId" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"ResubmitTicketIdMustExist" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"ResubmitTicketMustSame" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"ResubmitTicketSentTooOften" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"NotFoundChain" => _serde::__private::Ok(__Field::__field12),
                            b"NotFoundToken" => _serde::__private::Ok(__Field::__field13),
                            b"NotFoundAccountToken" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"NotFoundChainToken" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"NotSufficientTokens" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            b"TicketAmountParseError" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            b"EcdsaPublicKeyError" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            b"SighWithEcdsaError" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            b"CustomError" => _serde::__private::Ok(__Field::__field20),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Error>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Error;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Error",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::ChainAlreadyExisting,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::TokenAlreadyExisting,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::NotSupportedProposal)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::ProposalError,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::GenerateDirectiveError,
                                )
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::MalformedMessageBytes)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::Unauthorized)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::DeactiveChain,
                                )
                            }
                            (__Field::__field8, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::AlreadyExistingTicketId,
                                )
                            }
                            (__Field::__field9, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::ResubmitTicketIdMustExist)
                            }
                            (__Field::__field10, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::ResubmitTicketMustSame)
                            }
                            (__Field::__field11, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::ResubmitTicketSentTooOften)
                            }
                            (__Field::__field12, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::NotFoundChain,
                                )
                            }
                            (__Field::__field13, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::NotFoundToken,
                                )
                            }
                            (__Field::__field14, __variant) => {
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Error>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Error;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "tuple variant Error::NotFoundAccountToken",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"tuple variant Error::NotFoundAccountToken with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"tuple variant Error::NotFoundAccountToken with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"tuple variant Error::NotFoundAccountToken with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(
                                            Error::NotFoundAccountToken(__field0, __field1, __field2),
                                        )
                                    }
                                }
                                _serde::de::VariantAccess::tuple_variant(
                                    __variant,
                                    3usize,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Error>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field15, __variant) => {
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Error>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Error;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "tuple variant Error::NotFoundChainToken",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"tuple variant Error::NotFoundChainToken with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"tuple variant Error::NotFoundChainToken with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(
                                            Error::NotFoundChainToken(__field0, __field1),
                                        )
                                    }
                                }
                                _serde::de::VariantAccess::tuple_variant(
                                    __variant,
                                    2usize,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Error>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field16, __variant) => {
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Error>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Error;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "tuple variant Error::NotSufficientTokens",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"tuple variant Error::NotSufficientTokens with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"tuple variant Error::NotSufficientTokens with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(
                                            Error::NotSufficientTokens(__field0, __field1),
                                        )
                                    }
                                }
                                _serde::de::VariantAccess::tuple_variant(
                                    __variant,
                                    2usize,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Error>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field17, __variant) => {
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Error>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Error;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "tuple variant Error::TicketAmountParseError",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"tuple variant Error::TicketAmountParseError with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"tuple variant Error::TicketAmountParseError with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(
                                            Error::TicketAmountParseError(__field0, __field1),
                                        )
                                    }
                                }
                                _serde::de::VariantAccess::tuple_variant(
                                    __variant,
                                    2usize,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Error>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field18, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::EcdsaPublicKeyError,
                                )
                            }
                            (__Field::__field19, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::SighWithEcdsaError,
                                )
                            }
                            (__Field::__field20, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::CustomError,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "ChainAlreadyExisting",
                    "TokenAlreadyExisting",
                    "NotSupportedProposal",
                    "ProposalError",
                    "GenerateDirectiveError",
                    "MalformedMessageBytes",
                    "Unauthorized",
                    "DeactiveChain",
                    "AlreadyExistingTicketId",
                    "ResubmitTicketIdMustExist",
                    "ResubmitTicketMustSame",
                    "ResubmitTicketSentTooOften",
                    "NotFoundChain",
                    "NotFoundToken",
                    "NotFoundAccountToken",
                    "NotFoundChainToken",
                    "NotSufficientTokens",
                    "TicketAmountParseError",
                    "EcdsaPublicKeyError",
                    "SighWithEcdsaError",
                    "CustomError",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Error",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Error>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Error::ChainAlreadyExisting(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ChainAlreadyExisting",
                        &__self_0,
                    )
                }
                Error::TokenAlreadyExisting(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TokenAlreadyExisting",
                        &__self_0,
                    )
                }
                Error::NotSupportedProposal => {
                    ::core::fmt::Formatter::write_str(f, "NotSupportedProposal")
                }
                Error::ProposalError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ProposalError",
                        &__self_0,
                    )
                }
                Error::GenerateDirectiveError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "GenerateDirectiveError",
                        &__self_0,
                    )
                }
                Error::MalformedMessageBytes => {
                    ::core::fmt::Formatter::write_str(f, "MalformedMessageBytes")
                }
                Error::Unauthorized => {
                    ::core::fmt::Formatter::write_str(f, "Unauthorized")
                }
                Error::DeactiveChain(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DeactiveChain",
                        &__self_0,
                    )
                }
                Error::AlreadyExistingTicketId(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AlreadyExistingTicketId",
                        &__self_0,
                    )
                }
                Error::ResubmitTicketIdMustExist => {
                    ::core::fmt::Formatter::write_str(f, "ResubmitTicketIdMustExist")
                }
                Error::ResubmitTicketMustSame => {
                    ::core::fmt::Formatter::write_str(f, "ResubmitTicketMustSame")
                }
                Error::ResubmitTicketSentTooOften => {
                    ::core::fmt::Formatter::write_str(f, "ResubmitTicketSentTooOften")
                }
                Error::NotFoundChain(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NotFoundChain",
                        &__self_0,
                    )
                }
                Error::NotFoundToken(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NotFoundToken",
                        &__self_0,
                    )
                }
                Error::NotFoundAccountToken(__self_0, __self_1, __self_2) => {
                    ::core::fmt::Formatter::debug_tuple_field3_finish(
                        f,
                        "NotFoundAccountToken",
                        __self_0,
                        __self_1,
                        &__self_2,
                    )
                }
                Error::NotFoundChainToken(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "NotFoundChainToken",
                        __self_0,
                        &__self_1,
                    )
                }
                Error::NotSufficientTokens(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "NotSufficientTokens",
                        __self_0,
                        &__self_1,
                    )
                }
                Error::TicketAmountParseError(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "TicketAmountParseError",
                        __self_0,
                        &__self_1,
                    )
                }
                Error::EcdsaPublicKeyError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EcdsaPublicKeyError",
                        &__self_0,
                    )
                }
                Error::SighWithEcdsaError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SighWithEcdsaError",
                        &__self_0,
                    )
                }
                Error::CustomError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CustomError",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for Error {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for Error {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                Error::ChainAlreadyExisting(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The chain(`{0}`) already exists",
                                _0.as_display(),
                            ),
                        )
                }
                Error::TokenAlreadyExisting(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The token(`{0}`) already exists",
                                _0.as_display(),
                            ),
                        )
                }
                Error::NotSupportedProposal {} => {
                    __formatter.write_str("not supported proposal")
                }
                Error::ProposalError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("proposal error: (`{0}`)", _0.as_display()),
                        )
                }
                Error::GenerateDirectiveError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "generate directive error for : (`{0}`)",
                                _0.as_display(),
                            ),
                        )
                }
                Error::MalformedMessageBytes {} => {
                    __formatter
                        .write_str(
                            "the message is malformed and cannot be decoded error",
                        )
                }
                Error::Unauthorized {} => __formatter.write_str("unauthorized"),
                Error::DeactiveChain(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("The `{0}` is deactive", _0.as_display()),
                        )
                }
                Error::AlreadyExistingTicketId(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The ticket id (`{0}`) already exists!",
                                _0.as_display(),
                            ),
                        )
                }
                Error::ResubmitTicketIdMustExist {} => {
                    __formatter.write_str("The resubmit ticket id must exist!")
                }
                Error::ResubmitTicketMustSame {} => {
                    __formatter
                        .write_str("The resubmit ticket must same as the old ticket!")
                }
                Error::ResubmitTicketSentTooOften {} => {
                    __formatter.write_str("The resumit ticket sent too often")
                }
                Error::NotFoundChain(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("not found chain: (`{0}`)", _0.as_display()),
                        )
                }
                Error::NotFoundToken(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("not found token: (`{0}`)", _0.as_display()),
                        )
                }
                Error::NotFoundAccountToken(_0, _1, _2) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "not found account(`{0}`) token(`{1}`) on the chain(`{2}`",
                                _0.as_display(),
                                _1.as_display(),
                                _2.as_display(),
                            ),
                        )
                }
                Error::NotFoundChainToken(_0, _1) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Not found this token(`{0}`) on chain(`{1}`) ",
                                _0.as_display(),
                                _1.as_display(),
                            ),
                        )
                }
                Error::NotSufficientTokens(_0, _1) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Insufficient token (`{0}`) on chain (`{1}`) !)",
                                _0.as_display(),
                                _1.as_display(),
                            ),
                        )
                }
                Error::TicketAmountParseError(_0, _1) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The ticket amount(`{0}`) parse error: `{1}`",
                                _0.as_display(),
                                _1.as_display(),
                            ),
                        )
                }
                Error::EcdsaPublicKeyError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "ecdsa_public_key failed : (`{0}`)",
                                _0.as_display(),
                            ),
                        )
                }
                Error::SighWithEcdsaError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "sign_with_ecdsa failed: (`{0}`)",
                                _0.as_display(),
                            ),
                        )
                }
                Error::CustomError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("custom error: (`{0}`)", _0.as_display()),
                        )
                }
            }
        }
    }
}
pub mod updates {
    pub mod add_new_token {
        use crate::audit;
        use crate::state::{mutate_state, read_state};
        use crate::types::Token;
        use candid::{CandidType, Deserialize};
        pub enum AddNewTokenError {
            AlreadyAdded(String),
            CreateLedgerErr(String),
        }
        impl ::candid::types::CandidType for AddNewTokenError {
            fn _ty() -> ::candid::types::Type {
                ::candid::types::TypeInner::Variant(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::candid::types::Field {
                                    id: ::candid::types::Label::Named(
                                            "CreateLedgerErr".to_owned(),
                                        )
                                        .into(),
                                    ty: <String as ::candid::types::CandidType>::ty(),
                                },
                                ::candid::types::Field {
                                    id: ::candid::types::Label::Named("AlreadyAdded".to_owned())
                                        .into(),
                                    ty: <String as ::candid::types::CandidType>::ty(),
                                },
                            ]),
                        ),
                    )
                    .into()
            }
            fn id() -> ::candid::types::TypeId {
                ::candid::types::TypeId::of::<AddNewTokenError>()
            }
            fn idl_serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::std::result::Result<(), __S::Error>
            where
                __S: ::candid::types::Serializer,
            {
                match *self {
                    AddNewTokenError::CreateLedgerErr(ref __field0) => {
                        let mut ser = __serializer.serialize_variant(0u64)?;
                        ::candid::types::Compound::serialize_element(
                            &mut ser,
                            __field0,
                        )?;
                    }
                    AddNewTokenError::AlreadyAdded(ref __field0) => {
                        let mut ser = __serializer.serialize_variant(1u64)?;
                        ::candid::types::Compound::serialize_element(
                            &mut ser,
                            __field0,
                        )?;
                    }
                };
                Ok(())
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AddNewTokenError {
            #[inline]
            fn clone(&self) -> AddNewTokenError {
                match self {
                    AddNewTokenError::AlreadyAdded(__self_0) => {
                        AddNewTokenError::AlreadyAdded(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    AddNewTokenError::CreateLedgerErr(__self_0) => {
                        AddNewTokenError::CreateLedgerErr(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AddNewTokenError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    AddNewTokenError::AlreadyAdded(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "AlreadyAdded",
                            &__self_0,
                        )
                    }
                    AddNewTokenError::CreateLedgerErr(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CreateLedgerErr",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AddNewTokenError {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "AlreadyAdded" => _serde::__private::Ok(__Field::__field0),
                                "CreateLedgerErr" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"AlreadyAdded" => _serde::__private::Ok(__Field::__field0),
                                b"CreateLedgerErr" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AddNewTokenError>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AddNewTokenError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum AddNewTokenError",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        AddNewTokenError::AlreadyAdded,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        AddNewTokenError::CreateLedgerErr,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "AlreadyAdded",
                        "CreateLedgerErr",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "AddNewTokenError",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AddNewTokenError>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AddNewTokenError {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AddNewTokenError {
            #[inline]
            fn eq(&self, other: &AddNewTokenError) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            AddNewTokenError::AlreadyAdded(__self_0),
                            AddNewTokenError::AlreadyAdded(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            AddNewTokenError::CreateLedgerErr(__self_0),
                            AddNewTokenError::CreateLedgerErr(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for AddNewTokenError {}
        #[automatically_derived]
        impl ::core::cmp::Eq for AddNewTokenError {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        pub async fn add_new_token(token: Token) -> Result<(), AddNewTokenError> {
            if read_state(|s| s.tokens.contains_key(&token.token_id)) {
                return Err(AddNewTokenError::AlreadyAdded(token.token_id));
            }
            mutate_state(|s| {
                audit::add_token(s, token);
            });
            Ok(())
        }
    }
    pub use add_new_token::add_new_token;
}
type Result<T = ()> = std::result::Result<T, Error>;
pub enum Error {
    #[error("Hub error: {0}")]
    HubError(String),
    #[error("Evm rpc canister error: {0}")]
    EvmRpcCanisterError(String),
    #[error("Evm rpc error: {0}")]
    EvmRpcError(String),
    #[error("Chain key error: {0}")]
    ChainKeyError(String),
    #[error("Parse event error: {0}")]
    ParseEventError(String),
    #[error("Route not initialized")]
    RouteNotInitialized,
    #[error("IC call error: {0:?}, {1}")]
    IcCallError(RejectionCode, String),
    #[error(transparent)]
    Custom(#[from] anyhow::Error),
}
#[allow(unused_qualifications)]
impl std::error::Error for Error {
    fn source(&self) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
        use thiserror::__private::AsDynError as _;
        #[allow(deprecated)]
        match self {
            Error::HubError { .. } => ::core::option::Option::None,
            Error::EvmRpcCanisterError { .. } => ::core::option::Option::None,
            Error::EvmRpcError { .. } => ::core::option::Option::None,
            Error::ChainKeyError { .. } => ::core::option::Option::None,
            Error::ParseEventError { .. } => ::core::option::Option::None,
            Error::RouteNotInitialized { .. } => ::core::option::Option::None,
            Error::IcCallError { .. } => ::core::option::Option::None,
            Error::Custom { 0: transparent } => {
                std::error::Error::source(transparent.as_dyn_error())
            }
        }
    }
}
#[allow(unused_qualifications)]
impl ::core::fmt::Display for Error {
    fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use thiserror::__private::AsDisplay as _;
        #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
        match self {
            Error::HubError(_0) => {
                __formatter.write_fmt(format_args!("Hub error: {0}", _0.as_display()))
            }
            Error::EvmRpcCanisterError(_0) => {
                __formatter
                    .write_fmt(
                        format_args!("Evm rpc canister error: {0}", _0.as_display()),
                    )
            }
            Error::EvmRpcError(_0) => {
                __formatter
                    .write_fmt(format_args!("Evm rpc error: {0}", _0.as_display()))
            }
            Error::ChainKeyError(_0) => {
                __formatter
                    .write_fmt(format_args!("Chain key error: {0}", _0.as_display()))
            }
            Error::ParseEventError(_0) => {
                __formatter
                    .write_fmt(format_args!("Parse event error: {0}", _0.as_display()))
            }
            Error::RouteNotInitialized {} => {
                __formatter.write_str("Route not initialized")
            }
            Error::IcCallError(_0, _1) => {
                __formatter
                    .write_fmt(
                        format_args!("IC call error: {0:?}, {1}", _0, _1.as_display()),
                    )
            }
            Error::Custom(_0) => ::core::fmt::Display::fmt(_0, __formatter),
        }
    }
}
#[allow(unused_qualifications)]
impl ::core::convert::From<anyhow::Error> for Error {
    #[allow(deprecated)]
    fn from(source: anyhow::Error) -> Self {
        Error::Custom { 0: source }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            Error::HubError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HubError",
                    &__self_0,
                )
            }
            Error::EvmRpcCanisterError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "EvmRpcCanisterError",
                    &__self_0,
                )
            }
            Error::EvmRpcError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "EvmRpcError",
                    &__self_0,
                )
            }
            Error::ChainKeyError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ChainKeyError",
                    &__self_0,
                )
            }
            Error::ParseEventError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ParseEventError",
                    &__self_0,
                )
            }
            Error::RouteNotInitialized => {
                ::core::fmt::Formatter::write_str(f, "RouteNotInitialized")
            }
            Error::IcCallError(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "IcCallError",
                    __self_0,
                    &__self_1,
                )
            }
            Error::Custom(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Custom", &__self_0)
            }
        }
    }
}
