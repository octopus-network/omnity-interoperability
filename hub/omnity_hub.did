type Action = variant { Redeem; Transfer };
type ChainInfo = record {
  chain_state : State;
  chain_name : text;
  chain_type : ChainType;
};
type ChainState = record { state : State; chain_id : text };
type ChainType = variant { SettlementChain; ExecutionChain };
type Error = variant {
  MalformedMessageBytes;
  ProposalError : text;
  NotSupportedProposal;
  Unauthorized;
  CustomError : text;
};
type Fee = record { fee_token : text; dst_chain_id : text; factor : int64 };
type Network = variant { mainnet; local; testnet };
type Proposal = variant {
  UpdateFee : Fee;
  AddToken : TokenMetaData;
  ChangeChainState : ChainState;
  AddChain : ChainInfo;
};
type PublicKeyReply = record { public_key : vec nat8 };
type Result = variant { Ok; Err : Error };
type Result_1 = variant { Ok : PublicKeyReply; Err : Error };
type Result_2 = variant {
  Ok : opt vec record { nat64; Proposal };
  Err : Error;
};
type Result_3 = variant { Ok : opt vec record { nat64; Ticket }; Err : Error };
type Result_4 = variant { Ok : text; Err : Error };
type State = variant { Active; Reinstate; Suspend };
type Ticket = record {
  token : text;
  action : Action;
  dst_chain : text;
  memo : opt vec nat8;
  ticket_id : text;
  sender : text;
  src_chain : text;
  amount : text;
  receiver : text;
  created_time : nat64;
};
type TokenMetaData = record {
  decimals : nat8;
  icon : opt text;
  name : text;
  issue_chain : text;
  symbol : text;
};
service : () -> {
  build_directive : (Proposal) -> (Result);
  get_pub_key : (Network) -> (Result_1);
  query_directives : (text, nat64, nat64) -> (Result_2) query;
  query_tickets : (text, nat64, nat64) -> (Result_3) query;
  send_ticket : (Ticket) -> (Result);
  set_owner : (principal) -> (Result);
  set_whitelist : (principal, bool) -> (Result);
  update_fee : (Fee) -> (Result);
  validate_proposal : (Proposal) -> (Result_4);
}
